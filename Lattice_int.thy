theory Lattice_int

imports "Jordan_Normal_Form.Matrix"
        "Jordan_Normal_Form.VS_Connect"
        "BenOr_Kozen_Reif.More_Matrix"

begin

text \<open>Connect the type vec to records of rings, commutative rings, fields and modules in order to
  use properties of modules such as lin_indpt (linear independence).\<close>


lemma dim_carrier: "dim_vec z = dim_col A \<Longrightarrow> A *\<^sub>v z \<in> carrier_vec (dim_row A)"
  by (metis carrier_vec_dim_vec dim_mult_mat_vec)


text \<open>Concrete type conversion int vec to real vec\<close>
definition real_of_int_vec :: "int vec \<Rightarrow> real vec"  where
  "real_of_int_vec v = map_vec real_of_int v"

definition real_to_int_vec :: "real vec \<Rightarrow> int vec"  where
  "real_to_int_vec v = map_vec floor v"


lemma[simp]: "dim_vec (real_of_int_vec v) = dim_vec v" 
  unfolding real_of_int_vec_def by auto

lemma real_of_int_vec_nth[simp, intro]: 
  "i<dim_vec v \<Longrightarrow> (real_of_int_vec v) $ i = real_of_int (v$i)"
by (simp add: real_of_int_vec_def)

lemma real_of_int_vec_vec:
  "real_of_int_vec (vec n f) = vec n (real_of_int \<circ> f)"
by (auto simp add: real_of_int_vec_def)

text \<open>Concrete type conversion int mat to real mat\<close>
definition real_of_int_mat :: "int mat \<Rightarrow> real mat"  where
  "real_of_int_mat A = map_mat real_of_int A"

definition real_to_int_mat :: "real mat \<Rightarrow> int mat"  where
  "real_to_int_mat A = map_mat floor A"


lemma[simp]: "dim_col (real_of_int_mat A) = dim_col A" 
  unfolding real_of_int_mat_def by auto

lemma[simp]: "dim_row (real_of_int_mat A) = dim_row A" 
  unfolding real_of_int_mat_def by auto

lemma real_of_int_mat_nth[simp, intro]: 
  "i<dim_row A \<Longrightarrow> j<dim_col A \<Longrightarrow> (real_of_int_mat A) $$ (i,j) = real_of_int (A $$ (i,j))"
by (simp add: real_of_int_mat_def)

lemma real_of_int_mat_mat:
  "real_of_int_mat (mat n m f) = mat n m (real_of_int \<circ> f)"
by (auto simp add: real_of_int_mat_def)

lemma real_of_int_mat_cols:
"cols (real_of_int_mat A) = map real_of_int_vec (cols A)"
by (simp add: list_eq_iff_nth_eq real_of_int_mat_def real_of_int_vec_def)

lemma distinct_cols_real_of_int_mat:
 "distinct (cols A) = distinct (cols (real_of_int_mat A))"
by (smt (verit, best) cols_length distinct_conv_nth index_map_mat(3) nth_map 
  of_int_hom.vec_hom_inj real_of_int_mat_cols real_of_int_mat_def real_of_int_vec_def)

text \<open>Algebraic lattices are discrete additive subgroups of $\mathbb{R}^n$.
  Lattices can be represented by a basis, multiple bases can represent the same lattice.\<close>
type_synonym int_lattice = "int vec set"

text \<open>Linear independence\<close>

definition is_indep :: "int mat \<Rightarrow> bool" where
  "is_indep A \<equiv> (\<forall>z::real vec. (real_of_int_mat A *\<^sub>v z = 0\<^sub>v (dim_row A) \<and> 
    dim_vec z = dim_col A) \<longrightarrow> z = 0\<^sub>v (dim_vec z))"


text \<open>properties of lattices\<close>

definition is_lattice :: "int_lattice \<Rightarrow> bool" where
  "is_lattice L \<equiv> (\<exists>B::(int mat). 
    L = {B *\<^sub>v z | z::int vec. dim_vec z = dim_col B} 
    \<and> is_indep B)"


text \<open>The lattice generated by the column vectors of a matrix. 
  This matrix does not need to be linearly independent. 
  Make certain that the output is indeed a lattice and not the entire space.\<close>
definition gen_lattice :: "int mat \<Rightarrow> int vec set" where
  "gen_lattice A = {A *\<^sub>v z | z::int vec. dim_vec z = dim_col A}"




text \<open>Theorems\<close>
lemma finsum_vec_carrier:
assumes "f ` A \<subseteq> carrier_vec nr" "finite A"
shows "finsum_vec TYPE('a::ring) nr f A \<in> carrier_vec nr" 
using assms unfolding finsum_vec_def
by (metis (no_types, lifting) Pi_I' comm_monoid.finprod_closed comm_monoid_vec 
  image_subset_iff monoid_vec_simps(2))

lemma dim_vec_finsum_vec:
assumes "f ` A \<subseteq> carrier_vec nr" "finite A"
shows "dim_vec (finsum_vec TYPE('a::ring) nr f A) = nr" 
using assms finsum_vec_carrier by (metis carrier_vecD)
    

lemma mat_mult_as_col_span:
assumes "(A :: 'a :: comm_ring mat) \<in> carrier_mat nr nc"
  and "(z :: 'a vec) \<in> carrier_vec nc"
shows "A *\<^sub>v z = finsum_vec TYPE('a) nr (\<lambda>i. z$i \<cdot>\<^sub>v col A i) {0..<nc}"
  (is "?left = ?right")
proof -
  have *: "finsum_vec TYPE('a) nr (\<lambda>i. z$i \<cdot>\<^sub>v col A i) {0..<nc} $ j = (A *\<^sub>v z) $ j" 
    if "j<nr" for j
  proof -
    have "finsum_vec TYPE('a) nr (\<lambda>i. z$i \<cdot>\<^sub>v col A i) {0..<nc} $ j = 
      sum (\<lambda>i. (z$i \<cdot>\<^sub>v col A i) $ j) {0..<nc}"
      by (subst index_finsum_vec, use assms that in \<open>auto\<close>)
    also have "\<dots> = sum (\<lambda>i. z$i * (col A i $ j)) {0..<nc}" 
      using assms(1) that by force
    also have "\<dots> = sum (\<lambda>i. z$i * A $$ (j,i)) {0..<nc}" using assms that by auto
    also have "\<dots> = sum (\<lambda>i. A $$ (j,i) * z$i) {0..<nc}"
      by (meson mult.commute)
    also have "\<dots> = sum (\<lambda>i. row A j $ i * z $ i) {0..<nc}" 
      using assms that by (auto simp add: index_row(1)[symmetric] simp del: index_row(1))
    also have "\<dots> = (A *\<^sub>v z) $ j" 
      unfolding mult_mat_vec_def scalar_prod_def using assms that by auto
    finally show ?thesis by blast
  qed
  then show ?thesis
  proof (subst eq_vecI[of ?left ?right], goal_cases)
    case (1 i)
    have dim_nr: "dim_vec (A *\<^sub>v z) = nr" 
      using assms(1) dim_mult_mat_vec by blast
    show ?case using assms 1 unfolding dim_nr by auto
  next
    case 2
    then show ?case using assms by (subst dim_vec_finsum_vec, auto)
  qed auto
qed

lemma mat_index:
"B = mat (dim_row B) (dim_col B) (\<lambda>(i,j). B $$ (i,j))"
by auto

lemma col_unit_vec:
assumes "i<dim_col (B:: 'a :: {monoid_mult, semiring_0, zero_neq_one} mat)"
shows "B *\<^sub>v (unit_vec (dim_col B) i) = col B i" (is "?left = ?right")
proof -
  have "B $$ (ia, i) = (\<Sum>ib = 0..<dim_col B. B $$ (ia, ib) * (if ib = i then 1 else 0))" 
    if "ia < dim_row B" for ia 
  proof -
    have "(\<Sum>ib = 0..<dim_col B. B $$ (ia, ib) * (if ib = i then 1 else 0)) =
      (\<Sum>ib = 0..<dim_col B. (if ib = i then B $$ (ia, ib) else 0))"
      by (smt (verit, best) mult.right_neutral mult_zero_right sum.cong)
    also have "\<dots> = B $$ (ia, i) +
       (\<Sum>ib\<in> {0..<dim_col B}-{i}. (if ib = i then B $$ (ia, ib) else 0))"
      by (simp add: assms)
    also have "\<dots> =  B $$ (ia, i)" by simp
    finally show ?thesis by auto
  qed
  then show ?thesis using assms by (subst eq_vecI[of ?left ?right]) 
    (auto simp add: unit_vec_def scalar_prod_def) 
qed

lemma is_indep_not_null:
assumes "is_indep B" "i<dim_col B"
shows "col B i \<noteq> 0\<^sub>v (dim_row B)"
proof (rule ccontr)
  assume "\<not> (col B i \<noteq> 0\<^sub>v (dim_row B))"
  then have "col B i = 0\<^sub>v (dim_row B)" by auto
  then have "real_of_int_mat B *\<^sub>v (unit_vec (dim_col B) i) = 0\<^sub>v (dim_row B)" 
  using col_unit_vec 
  by (metis assms(2) col_map_mat index_map_mat(3) of_int_hom.vec_hom_zero real_of_int_mat_def)
  moreover have "dim_vec (unit_vec (dim_col B) i) = dim_col B" by auto
  moreover have "(unit_vec (dim_col B) i) \<noteq> 0\<^sub>v (dim_col B)" 
    by (simp add: assms(2))
  ultimately have "\<not> (is_indep B)" unfolding is_indep_def by auto
  then show False using assms by auto
qed

lemma col_in_gen_lattice: 
assumes "i<dim_col B"
shows "col B i \<in> gen_lattice B"
unfolding gen_lattice_def proof (safe) 
  have "col B i = B *\<^sub>v (unit_vec (dim_col B) i)" using col_unit_vec[OF assms] by auto
  moreover have "dim_vec (unit_vec (dim_col B) i) = dim_col B" by auto
  ultimately show "\<exists>z. col B i = B *\<^sub>v z \<and> dim_vec z = dim_col B" by auto
qed

(* Lemmas for base change*)
definition span :: "('a :: semiring_0) mat \<Rightarrow> 'a vec set"  where
"span B = {B *\<^sub>v z | z:: 'a vec. dim_vec z = dim_col B}"

definition dim :: "int mat \<Rightarrow> nat" where 
"dim B = (if \<exists>b. is_indep b \<and> span (real_of_int_mat b) = span (real_of_int_mat B) then
    dim_col (SOME b. is_indep b \<and> span (real_of_int_mat b) = span (real_of_int_mat B)) else 0)"

definition set_cols[simp]: "set_cols A = set (cols A)"

definition insert_col:
"insert_col A c = mat_of_cols (dim_row A) (c # cols A)"

definition delete_col:
"delete_col A c = mat_of_cols (dim_row A) (filter (\<lambda> x. \<not> (x = c)) (cols A))"

lemma set_cols_col:
"set_cols A = col A ` {0..<dim_col A}"
by (simp add: cols_def)

lemma set_cols_subset_col:
assumes "set_cols A \<subseteq> set_cols B"
  "i<dim_col A"
obtains j where "col A i = col B j" 
proof -
  have "col A i \<in> set_cols B" using assms
    by (metis cols_length cols_nth nth_mem set_cols subsetD)
  then have "\<exists>j. col A i = col B j \<and> j<dim_col B"
    using set_cols_col by fastforce
  then show ?thesis using that by blast
qed

lemma span_mono:
assumes "set_cols (A ::'a::comm_ring mat) \<subseteq> set_cols B" "dim_row A = dim_row B" 
    "distinct (cols A)"
shows "span A \<subseteq> span B"
using assms proof (induction "card (set_cols B - set_cols A)" arbitrary: A B rule: less_induct)
  case less
  then show ?case unfolding span_def 
  proof (safe, goal_cases)
    case (1 _ z)
    define nr where "nr = dim_row B"
    define nc where "nc = dim_col B"
    have 2: "B \<in> carrier_mat nr nc" unfolding nr_def nc_def by auto
    have 3: "set (cols A) \<subseteq> set (cols B)" using less.prems(1) by auto
    have 4: "z \<in> carrier_vec (length (cols A))" using 1(5)
    by (metis carrier_vec_dim_vec cols_length)
    have 5: "mat_of_cols nr (cols A) = A" 
    by (metis less.prems(2) mat_of_cols_cols nr_def)
    obtain zb where "A *\<^sub>v z = B *\<^sub>v zb" "dim_vec zb = dim_col B" 
      using helper3[of B nr nc "cols A" z, OF 2 less.prems(3) 3 4] unfolding nc_def 5 by auto
    then show ?case by auto
  qed
qed


lemma is_indep_mono:
assumes "set_cols B \<subseteq> set_cols A" "is_indep A" "distinct (cols B)" "dim_row A = dim_row B"
shows "is_indep B"
unfolding is_indep_def 
proof (safe, goal_cases)
  case (1 z)
  define A' where "A' = real_of_int_mat A"
  define B' where "B' = real_of_int_mat B"
  define nr where "nr = dim_row A'"
  define nc where "nc = dim_col A'"
  have r: "nr = dim_row B'" unfolding nr_def A'_def B'_def using assms(4) by auto
  have A': "A' \<in> carrier_mat nr nc" unfolding nr_def nc_def by auto
  define ss where "ss = cols (B')"
  have d: "distinct (cols B')" using assms(3) unfolding B'_def 
  by (simp add: distinct_cols_real_of_int_mat) 
  have sub: "set (cols B') \<subseteq> set (cols A')" unfolding A'_def B'_def
  using assms(1) real_of_int_mat_cols by auto
  from distinct_list_subset_nths[of "cols B'" "cols A'", OF d sub] 
  obtain ids where ids: "distinct ids" "set ids \<subseteq> {..<length (cols A')}"
    and ss: "ss = map ((!) (cols A')) ids"
    using assms(1) set_cols ss_def by blast
  let ?ls = " map ((!) (cols A')) (filter (\<lambda>i. i \<notin> set ids) [0..<length (cols A')])"
  from subindex_permutation2[OF ids] obtain f where
    f: "f permutes {..<length (cols A')}"
    "cols A' = permute_list f (?ls @ ss)" using ss by blast
  have f': "f permutes {..<nc}" using f(1) unfolding nc_def by simp
  have *: "\<And>x. x \<in> set ?ls \<Longrightarrow> dim_vec x = nr" using A' by auto 
  let ?cs1 = "(list_of_vec (0\<^sub>v (length ?ls) @\<^sub>v z))"
  have z: "z \<in> carrier_vec (length ss)" unfolding ss_def using 1 
  using B'_def carrier_dim_vec by auto
  have "0\<^sub>v nr = B' *\<^sub>v z" using 1 unfolding B'_def r by auto
  also have "\<dots> = mat_of_cols nr ss *\<^sub>v z" unfolding ss_def r by simp
  also have "\<dots> = mat_of_cols nr (?ls @ ss) *\<^sub>v vec_of_list (?cs1)"
    using helper2[OF z] * by (metis vec_list)
  also have "... = mat_of_cols nr (permute_list f (?ls @ ss)) *\<^sub>v vec_of_list (permute_list f ?cs1)"
    by (auto intro!: mat_of_cols_mult_mat_vec_permute_list[symmetric])
       (metis cols_length f(1) f(2) length_append length_map length_permute_list,
        use ss_def z in \<open>force\<close>)
  also have "... =  A' *\<^sub>v vec_of_list (permute_list f ?cs1)" using f(2) 
    by (simp add: nr_def)
  finally have "A' *\<^sub>v vec_of_list (permute_list f ?cs1) = 0\<^sub>v nr" 
  by presburger
  then have zero: "vec_of_list (permute_list f ?cs1) = 0\<^sub>v nc" 
  by (smt (verit, best) A'_def assms(2) carrier_vecD cols_length dim_vec_of_list f(2) 
    index_append_vec(2) index_map_mat(2) index_map_mat(3) index_zero_vec(2) is_indep_def 
    length_append length_list_of_vec length_permute_list nc_def nr_def real_of_int_mat_def z)
  then have *:  "permute_list f ?cs1 ! i = 0" if "i<nc" for i
    by (metis index_zero_vec(1) that vec_of_list_index)
  then have "?cs1 ! (f i) = 0" if "i<nc" for i 
    by (metis cols_length dim_vec_of_list f(1) index_zero_vec(2) length_permute_list nc_def 
    permute_list_nth that zero)
  then have "(\<lambda>i. ?cs1 ! (f i)) ` {..<nc} \<subseteq> {0}" by blast
  then have "(\<lambda>i. ?cs1 ! i) ` (f `{..<nc}) \<subseteq> {0}" by blast
  then have "(\<lambda>i. ?cs1 ! i) ` {..<nc} \<subseteq> {0}" using permutes_imp_bij[OF f'] 
  by (metis cols_length f' length_map nc_def permutes_image)
  then have *: "?cs1 ! i = 0" if "i<nc" for i using that by blast
  then have "z $ i = 0" if "i<dim_vec z" for i using *[of "length ?ls + i"]
  by (metis (no_types, lifting) add_diff_cancel_left' add_less_cancel_left dim_vec_of_list 
    index_append_vec(2) index_zero_vec(2) length_list_of_vec length_permute_list  
    list_of_vec_append not_add_less1 nth_append nth_list_of_vec that zero)
  then show "z = 0\<^sub>v (dim_vec z)" 
  by (metis eq_vecI index_zero_vec(1) index_zero_vec(2))
qed



lemma is_indep_distinct:
assumes "is_indep A"
shows "distinct (cols A)"
proof (rule ccontr)
  define nc where "nc = dim_col A"
  define nr where "nr = dim_row A"
  assume "\<not> distinct (cols A)"
  then obtain i j where ij: "i \<noteq> j" "i<nc" "j<nc" "col A i = col A j"
    unfolding nc_def by (metis cols_length cols_nth distinct_conv_nth)
  have "(real_of_int_mat A) *\<^sub>v (unit_vec nc i - unit_vec nc j) = 0\<^sub>v nr"
    by (smt (verit, ccfv_threshold) ij carrier_mat_triv col_dim col_map_mat col_unit_vec 
      index_map_mat(2) index_map_mat(3) minus_cancel_vec mult_minus_distrib_mat_vec nc_def 
      nr_def real_of_int_mat_def unit_vec_carrier)
  moreover have "dim_vec (unit_vec nc i - unit_vec nc j) = nc" by simp
  moreover have "(unit_vec nc i - unit_vec nc j) \<noteq> 0\<^sub>v nc" 
  by (smt (z3) assms calculation(1) calculation(2) ij(1) ij(2) ij(3) index_minus_vec(1) 
    index_minus_vec(2) index_unit_vec(1) index_zero_vec(1) is_indep_def nc_def nr_def)
  ultimately have "\<not> is_indep A" unfolding is_indep_def
  using nc_def nr_def by auto
  then show False using assms by auto
qed

lemma span_base:
assumes "(a :: 'a :: {monoid_mult,semiring_0,zero_neq_one} vec) \<in> set_cols S"
shows "a \<in> span S"
proof -
  obtain i where "i<dim_col S" "a = col S i" using assms 
  by (metis atLeastLessThan_iff imageE set_cols_col)
  then have "a = S *\<^sub>v (unit_vec (dim_col S) i)" 
    using col_unit_vec[OF \<open>i<dim_col S\<close>, symmetric] by auto
  then show ?thesis unfolding span_def by auto
qed



text \<open>Representing function\<close>


definition representation :: "int mat \<Rightarrow> int vec \<Rightarrow> int vec \<Rightarrow> int"
  where "representation B v =
    (if is_indep B \<and> v \<in> (span B) then
      SOME f. (\<forall>v. f v \<noteq> 0 \<longrightarrow> v \<in> set_cols B) \<and>
        B *\<^sub>v (vec (dim_col B) (\<lambda>i. f (col B i))) = v
    else (\<lambda>b. 0))"

lemma unique_representation:
  assumes basis: "is_indep basis"
    and in_basis: "\<And>v. f v \<noteq> 0 \<Longrightarrow> v \<in> set_cols basis" "\<And>v. g v \<noteq> 0 \<Longrightarrow> v \<in> set_cols basis"
    and eq: "basis *\<^sub>v (vec (dim_col basis) (\<lambda>i. f (col basis i))) = 
            basis *\<^sub>v (vec (dim_col basis) (\<lambda>i. g (col basis i)))"
  shows "f = g"
proof (rule ext, rule ccontr)
  fix v assume ne: "f v \<noteq> g v" 
  then have in_col: "v \<in> set_cols basis" using in_basis by metis
  have "\<not> is_indep basis"
    unfolding is_indep_def
  proof (subst not_all, subst not_imp)
    let ?x = "vec (dim_col basis) (\<lambda>i. (f (col basis i)- g (col basis i)))"
    have  "\<exists>v\<in>set_cols basis. f v - g v \<noteq> 0" 
      using ne in_col right_minus_eq by blast
    then have ex: "\<exists>i<dim_col basis. f (col basis i) - g (col basis i) \<noteq> 0"
      by (metis atLeastLessThan_iff imageE set_cols_col)
    have "basis *\<^sub>v (?x) =
          basis *\<^sub>v (vec (dim_col basis) (\<lambda>i. f (col basis i))) - 
          basis *\<^sub>v (vec (dim_col basis) (\<lambda>i. g (col basis i)))"
    proof -
      have *: "?x = vec (dim_col basis) (\<lambda>i. f (col basis i)) - 
        vec (dim_col basis) (\<lambda>i. g (col basis i))" unfolding minus_vec_def by auto
      show ?thesis unfolding *
      by (meson carrier_mat_triv mult_minus_distrib_mat_vec vec_carrier)
    qed
    then have "basis *\<^sub>v (?x) = 0\<^sub>v (dim_row basis)" using eq by auto
    then have "real_of_int_mat basis *\<^sub>v (real_of_int_vec ?x) = 0\<^sub>v (dim_row basis)"
      by (metis (full_types) carrier_mat_triv of_int_hom.mult_mat_vec_hom of_int_hom.vec_hom_zero 
      real_of_int_mat_def real_of_int_vec_def vec_carrier)
    moreover have "dim_vec ?x = dim_col basis" 
    using dim_vec by blast
    then have "dim_vec (real_of_int_vec ?x) = dim_col basis" by simp
    moreover have "?x \<noteq> 0\<^sub>v (dim_col basis)" using ex
    by (metis (no_types, lifting) index_vec index_zero_vec(1)) 
    ultimately show "\<exists>x. (real_of_int_mat basis *\<^sub>v x = 0\<^sub>v (dim_row basis) \<and>
         dim_vec x = dim_col basis) \<and> x \<noteq> 0\<^sub>v (dim_vec x)" 
         using real_of_int_vec_def by auto
  qed
  with basis show False by auto
qed

lemma
  shows representation_ne_zero: "\<And>b. representation basis v b \<noteq> 0 \<Longrightarrow> b \<in> set_cols basis"
    and sum_nonzero_representation_eq:
      "is_indep basis \<Longrightarrow> v \<in> span basis \<Longrightarrow> 
      basis *\<^sub>v (vec (dim_col basis) (\<lambda>i. representation basis v (col basis i))) = v"
proof -
  { assume basis: "is_indep basis" and v: "v \<in> span basis"
    define p where "p f \<longleftrightarrow>
      (\<forall>v. f v \<noteq> 0 \<longrightarrow> v \<in> set_cols basis) \<and> 
      basis *\<^sub>v (vec (dim_col basis) (\<lambda>i. f (col basis i))) = v" for f
    obtain z where z: "basis *\<^sub>v z = v" "dim_vec z = dim_col basis"
      using \<open>v \<in> span basis\<close> unfolding span_def by auto
    define r where "r = (\<lambda>v. if (\<exists>i<dim_col basis. v = col basis i) 
      then z$(SOME i. i<dim_col basis \<and> v = col basis i) else 0)"
    then have "r (col basis i) = z$i" if "i<dim_col basis" for i 
    proof -
      have "z $ (SOME j. j<dim_col basis \<and> col basis ia = col basis j) = z $ i" 
        if "i < dim_col basis"
          "distinct (cols basis)"
          "ia < dim_col basis"
          "col basis i = col basis ia"
        for ia
      proof -
        have "i = ia" using that 
        by (metis cols_length cols_nth distinct_conv_nth)
        obtain j where j: "j = (SOME j. j<dim_col basis \<and> col basis i = col basis j)" by blast
        then have "j<dim_col basis" "col basis i = col basis j" 
        by (smt (verit, best) \<open>i = ia\<close> someI_ex that(3))
           (metis (mono_tags, lifting) j that(1) verit_sko_ex')
        then have "i = j" using that
        by (metis cols_length cols_nth distinct_conv_nth)
        then show ?thesis unfolding j(1) 
        using that(4) by auto
      qed
      then show ?thesis
      unfolding r_def using that is_indep_distinct[OF basis] by auto
    qed
    then have "z = (vec (dim_col basis) (\<lambda>i. r (col basis i)))"
       using z(2) by auto 
    then have *: 
      "basis *\<^sub>v (vec (dim_col basis) (\<lambda>i. r (col basis i))) = v"
      using z by auto
    define f where "f b = (if b \<in> set_cols basis then r b else 0)" for b
    have "p f"
      using * unfolding p_def f_def 
      by (smt (verit, best) cols_length cols_nth dim_vec eq_vecI index_vec nth_mem set_cols)
    have *: "representation basis v = Eps p" 
      by (simp add: p_def[abs_def] representation_def basis v)
    from someI[of p f, OF \<open>p f\<close>] have "p (representation basis v)"
      unfolding * . }
  note * = this

  show "representation basis v b \<noteq> 0 \<Longrightarrow> b \<in> set_cols basis" for b
    using * by (cases "is_indep basis \<and> v \<in> span basis") (auto simp: representation_def)

  show "is_indep basis \<Longrightarrow> v \<in> span basis \<Longrightarrow> 
    basis *\<^sub>v (vec (dim_col basis) (\<lambda>i. representation basis v (col basis i))) = v"
    using * by auto
qed

lemma representation_eqI:
  assumes basis: "is_indep basis" and b: "v \<in> span basis"
    and ne_zero: "\<And>b. f b \<noteq> 0 \<Longrightarrow> b \<in> set_cols basis"
    and eq: "basis *\<^sub>v (vec (dim_col basis) (\<lambda>i. f (col basis i))) = v"
  shows "representation basis v = f"
  by (rule unique_representation[OF basis])
     (auto simp: representation_ne_zero 
      sum_nonzero_representation_eq[OF basis b] ne_zero eq simp del: set_cols)

lemma representation_extend:
  assumes basis: "is_indep basis" and v: "v \<in> span basis'" 
    and basis': "set_cols basis' \<subseteq> set_cols basis" and d: "dim_row basis = dim_row basis'"
    and dc: "distinct (cols basis')" 
  shows "representation basis v = representation basis' v"
proof (rule representation_eqI[OF basis])
  show v': "v \<in> span basis" using span_mono[OF basis' d[symmetric] dc] v by auto
  have *: "is_indep basis'" using is_indep_mono[OF basis' basis dc d] by (auto)
  show "representation basis' v b \<noteq> 0 \<Longrightarrow> b \<in> set_cols basis" for b
    using representation_ne_zero basis' by auto
  have dim_row: "dim_row basis' = dim_row basis"
    by (metis "*" Lattice_int.sum_nonzero_representation_eq basis dim_mult_mat_vec v v')
  show "basis *\<^sub>v vec (dim_col basis) (\<lambda>i. Lattice_int.representation basis' v (col basis i)) = v "
  proof -
    have not_in': "representation basis' v b = 0" if "b \<notin> set_cols basis'" for b
    using Lattice_int.representation_ne_zero that by blast
    have "basis *\<^sub>v vec (dim_col basis) (\<lambda>i. Lattice_int.representation basis' v (col basis i)) = 
    basis' *\<^sub>v vec (dim_col basis') (\<lambda>i. Lattice_int.representation basis' v (col basis' i))"
    (is "?left = ?right")
    proof (subst eq_vecI[of ?left ?right, symmetric], goal_cases)
      case (1 i)
      define f where 
        "f = (\<lambda>basis k. row basis i $ k * (Lattice_int.representation basis' v (col basis k)))"
      have **: "(\<Sum>k = 0..<dim_col basis. f basis k) =
      (\<Sum>k = 0..<dim_col basis'. f basis' k)"
      proof -
        have lt: "dim_col basis' \<le> dim_col basis" using basis' dc is_indep_distinct[OF basis]
          by (metis List.finite_set card_mono cols_length distinct_card set_cols)
        have "l < dim_col basis' \<Longrightarrow> col basis' l = col basis x \<Longrightarrow> x < dim_col basis" for l x
           sorry
        have "(\<Sum>k = 0..<dim_col basis. f basis k) =
          (\<Sum>k \<in> {0..<dim_col basis}-{k. \<exists>l. l<dim_col basis' \<and> col basis' l = col basis k}. 
            f basis k) +
          (\<Sum>k \<in> {k. \<exists>l. l<dim_col basis' \<and> col basis' l = col basis k}. f basis k)" 
        apply (subst sum.subset_diff[of "{k. \<exists>l. l<dim_col basis' \<and> col basis' l = col basis k}"])
        apply (auto simp add: lt basis')
  apply (subst sum.subset_diff[of ], auto) sorry
        have "f basis k = 0" if "k \<in> {dim_col basis'..<dim_col basis}" for k unfolding f_def
          using not_in'   sorry
        show ?thesis sorry
      qed
      have "row basis i \<bullet> vec (dim_col basis)
            (\<lambda>j. Lattice_int.representation basis' v (col basis j)) = 
            row basis' i \<bullet> vec (dim_col basis')
            (\<lambda>j. Lattice_int.representation basis' v (col basis' j))" 
      unfolding scalar_prod_def using ** unfolding f_def
        by force
      then show ?case unfolding mult_mat_vec_def
        using "1" dim_row by force 
    qed (use dim_row in \<open>auto\<close>)
    then show ?thesis
    using sum_nonzero_representation_eq[OF * v] by auto
  qed
qed

lemma representation_basis:
  assumes basis: "is_indep basis" and b: "b \<in> set_cols basis"
  shows "representation basis b = (\<lambda>v. if v = b then 1 else 0)"
proof (rule unique_representation[OF basis])
  show "representation basis b v \<noteq> 0 \<Longrightarrow> v \<in> set_cols  basis" for v
    using representation_ne_zero .
  show "(if v = b then 1 else 0) \<noteq> 0 \<Longrightarrow> v \<in> set_cols basis" for v
    using b by (cases "v = b") (auto simp: b)
  have *: "{v. (if v = b then 1 else 0::int) \<noteq> 0} = {b}"
    by auto
  obtain j where j: "col basis j = b" "j<dim_col basis"
  by (metis atLeastLessThan_iff b imageE set_cols_col)
  have dis: "distinct (cols basis)" using basis is_indep_distinct by simp 
  have unit: "vec (dim_col basis) (\<lambda>i. if col basis i = b then 1 else 0) = 
    unit_vec (dim_col basis) j" (is "?l = ?r")
  proof (subst eq_vecI[of ?l ?r], goal_cases)
    case (1 i)
    then show ?case using dis j 
    by (smt (verit, best) cols_length cols_nth dim_vec distinct_conv_nth index_unit_vec(1) 
      index_vec)
  qed  auto
  show "basis *\<^sub>v vec (dim_col basis) (\<lambda>i. Lattice_int.representation basis b (col basis i)) =
    basis *\<^sub>v vec (dim_col basis) (\<lambda>i. if col basis i = b then 1 else 0)"
    using * sum_nonzero_representation_eq[OF basis span_base[OF b]] unfolding unit 
    by (subst col_unit_vec, simp add: j, unfold j(1), simp)
qed



(*
definition embed_rep:
"embed_rep A B v = vec (dim_col B) (\<lambda>i. if (\<exists>j. col A j = col B i) 
  then v $ (THE j. col A j = col B i) else 0)"


lemma embed_unit_vec:
"embed_rep A B (unit_vec (dim_col A) i) = unit_vec (dim_col B) (THE j. col A i = col B j)"
sorry


lemma embed_unit_vec_I:
assumes "dim_vec z = dim_col A" "embed_rep A B z = unit_vec (dim_col B) i" "i< dim_col B"
shows "\<exists>j. z = unit_vec (dim_col A) j"
oops

lemma embed_rep_eq:
assumes "set_cols A \<subseteq> set_cols B" "is_indep A" "dim_vec z = dim_col A"
shows "A *\<^sub>v z = B *\<^sub>v (embed_rep A B z)"
oops
*)
lemma mat_mult_eq_vec_eq:
assumes "A *\<^sub>v v = A *\<^sub>v w" "dim_vec v = dim_col A" "dim_vec w = dim_col A"
  "is_indep A"
shows "v = w"
oops

lemma spanning_subset_independent:
assumes BA: "set_cols B \<subseteq> set_cols A" and iA: "is_indep A" and AsB:"set_cols A \<subseteq> span B" 
  and d: "distinct (cols B)" and dr: "dim_row A = dim_row B"
shows "set_cols A = set_cols B"
proof (intro antisym[OF _ BA] subsetI)
  have iB: "is_indep B" using is_indep_mono[OF BA iA d dr] .
  fix v assume "v \<in> set_cols A"
  with AsB have "v \<in> span B" by auto
  let ?RB = "representation B v" and ?RA = "representation A v"
  have "?RB v = 1"
    unfolding representation_extend[OF iA \<open>v \<in> span B\<close> BA, symmetric] 
      representation_basis[OF iA \<open>v \<in> set_cols A\<close>] by simp
  then show "v \<in> set_cols B"
    using representation_ne_zero[of B v v] by auto
qed


lemma nth_lin_combo:
assumes "i < dim_row A" "dim_col A = dim_vec b"
shows "(A *\<^sub>v b) $ i = (\<Sum>j=0..<dim_col A. A $$ (i,j) * b $ j)"
using assms unfolding mult_mat_vec_def scalar_prod_def by auto




lemma in_span_insert:
  assumes a: "a \<in> span (insert_col S b)"
    and na: "a \<notin> span S"
  shows "b \<in> span (insert_col S a)"
sorry
(*
proof -
  from span_breakdown[of b "insert b S" a, OF insertI1 a]
  obtain k where k: "a - k *s b \<in> span (S - {b})" by auto
  have "k \<noteq> 0"
  proof
    assume "k = 0"
    with k span_mono[of "S - {b}" S] have "a \<in> span S" by auto
    with na show False by blast  
  qed
  then have eq: "b = (1/k) *s a - (1/k) *s (a - k *s b)"
    by (simp add: algebra_simps)

  from k have "(1/k) *s (a - k *s b) \<in> span (S - {b})"
    by (rule span_scale)
  also have "... \<subseteq> span (insert a S)"
    by (rule span_mono) auto
  finally show ?thesis
    using k by (subst eq) (blast intro: span_diff span_scale span_base)
qed
*)
lemma insert_delete_span:
assumes "a \<in> set_cols A"
shows "span (insert_col (delete_col A a) a) = span (A)"
using assms unfolding insert_col delete_col apply auto  sorry

lemma delete_not_in_set_cols:
assumes "b \<notin> set_cols T"
shows "delete_col T b = T"
unfolding delete_col using assms  
by (metis (mono_tags, lifting) filter_True mat_of_cols_cols set_cols)

lemma delete_col_span:
assumes "a \<in> span (delete_col T b)"
shows "a \<in> span T"
using assms unfolding delete_col
by (metis (no_types, lifting) Lattice_int.span_mono cols_dim cols_mat_of_cols filter_is_subset 
  in_mono mat_of_cols_carrier(2) set_cols subset_trans)

lemma in_span_delete:
assumes "a \<in> span T" "a \<notin> span (delete_col T b)"
shows "b \<in> span (insert_col (delete_col T b) a)"
proof (subst in_span_insert[of a "delete_col T b" b], goal_cases)
  case 1
  then show ?case proof (cases "b\<in>set_cols T")
    case True
    then show ?thesis by (simp add: assms(1) insert_delete_span)
  next
    case False
    then show ?thesis by (metis assms(1) assms(2) delete_not_in_set_cols)
  qed 
qed (use assms in \<open>auto\<close>)

lemma mat_of_cols_mult_vCons:
assumes "dim_vec (x :: 'a ::comm_ring vec) = dim_row S" "dim_vec zs = dim_col S"
shows "mat_of_cols (dim_row S) (x # cols S) *\<^sub>v vCons z0 zs = z0 \<cdot>\<^sub>v x + S *\<^sub>v zs"
using assms carrier_vec_dim_vec[of zs] 
unfolding assms(2) by (subst mat_of_cols_cons_mat_vec, auto)

lemma mult_mat_vec_ring:
  assumes m: "(A::'a::comm_ring mat) \<in> carrier_mat nr nc" and v: "v \<in> carrier_vec nc"
  shows "A *\<^sub>v (k \<cdot>\<^sub>v v) = k \<cdot>\<^sub>v (A *\<^sub>v v)" (is "?l = ?r")
proof
  have nr: "dim_vec ?l = nr" using m v by auto
  also have "... = dim_vec ?r" using m v by auto
  finally show "dim_vec ?l = dim_vec ?r".
  show "\<And>i. i < dim_vec ?r \<Longrightarrow> ?l $ i = ?r $ i"
  proof -
    fix i assume "i < dim_vec ?r"
    hence i: "i < dim_row A" using nr m by auto
    hence i2: "i < dim_vec (A *\<^sub>v v)" using m by auto
    show "?l $ i = ?r $ i"
    apply (subst (1) mult_mat_vec_def)
    apply (subst (2) smult_vec_def)
    unfolding index_vec[OF i] index_vec[OF i2]
    unfolding mult_mat_vec_def smult_vec_def
    unfolding scalar_prod_def index_vec[OF i]
    by (simp add: mult.left_commute sum_distrib_left)
  qed
qed

lemma span_redundant:
assumes "(x :: 'a ::comm_ring vec) \<in> span S" 
shows "span (insert_col S x) = span S"
proof 
  have "\<exists>za. insert_col S x *\<^sub>v z = S *\<^sub>v za \<and> dim_vec za = dim_col S" 
    if "dim_vec z = dim_col (insert_col S x)" for z 
  proof -
    have dim_z: "dim_vec z = dim_col S + 1" using that by (simp add: insert_col)
    obtain za where za_def: "z = vCons (z$0) za"
    by (metis \<open>dim_vec z = dim_col (insert_col S x)\<close> add_Suc_right dim_vec insert_col list.size(4) 
      mat_of_cols_carrier(3) nat.simps(3) vec_cases vec_index_vCons_0)
    obtain zx where zx_def: "x = S *\<^sub>v zx" "dim_col S = dim_vec zx" 
      using assms unfolding span_def by auto
    have "dim_vec x = dim_row S" using zx_def(1) by auto 
    moreover have "dim_vec za = dim_col S" 
    by (metis Suc_eq_plus1_left add.commute add_diff_cancel_left' dim_vec_vCons dim_z za_def)
    ultimately have "insert_col S x *\<^sub>v z = z$0 \<cdot>\<^sub>v x + S *\<^sub>v za" 
      unfolding insert_col by (subst za_def, subst mat_of_cols_mult_vCons, auto)
    also have "\<dots> = z$0 \<cdot>\<^sub>v (S *\<^sub>v zx) + S *\<^sub>v za" unfolding zx_def by auto
    also have "\<dots> = S *\<^sub>v (z $ 0 \<cdot>\<^sub>v zx) + S *\<^sub>v za"
      by (subst mult_mat_vec_ring[symmetric]) (auto simp add: zx_def(2))
    also have "\<dots> = S *\<^sub>v (z$0 \<cdot>\<^sub>v zx + za)" 
      by (metis \<open>dim_vec za = dim_col S\<close> carrier_matI carrier_vec_dim_vec index_smult_vec(2) 
      mult_add_distrib_mat_vec zx_def(2))
    finally have "insert_col S x *\<^sub>v z = S *\<^sub>v (z$0 \<cdot>\<^sub>v zx + za)" by blast
    moreover have "dim_vec (z$0 \<cdot>\<^sub>v zx + za) = dim_col S" 
    by (metis Suc_eq_plus1_left add.commute add_diff_cancel_left' dim_vec_vCons dim_z 
      index_add_vec(2) za_def) 
    ultimately show ?thesis by blast
  qed
  then show "span (insert_col S x) \<subseteq> span S" unfolding span_def by auto
next 
  have "\<exists>za. S *\<^sub>v z = insert_col S x *\<^sub>v za \<and>
              dim_vec za = dim_col (insert_col S x)" if "dim_vec z = dim_col S" for z
  proof -
    define za where za_def: "za = vCons 0 z"
    have "dim_vec za = dim_col S + 1" using that za_def by force
    then have "dim_vec za = dim_col (insert_col S x)"
    by (simp add: insert_col)
    moreover have "S *\<^sub>v z = insert_col S x *\<^sub>v za" 
    proof -
      have "dim_vec x = dim_row S"
      using Lattice_int.span_def assms by force
      moreover have "dim_vec z = dim_col S" 
      using that by blast
      moreover have "S *\<^sub>v z = 0 \<cdot>\<^sub>v x + S *\<^sub>v z"
      using calculation(1) by auto
      ultimately show ?thesis unfolding insert_col za_def 
        by (subst mat_of_cols_mult_vCons)
    qed
    ultimately show ?thesis by blast
  qed
  then show "span S \<subseteq> span (insert_col S x)" unfolding span_def by auto
qed


lemma span_trans:
assumes "(x :: 'a ::comm_ring vec) \<in> span S" "y \<in> span (insert_col S x)"
shows "y \<in> span S"
using Lattice_int.span_redundant assms by blast



lemma delet_col_not_in_set_cols:
assumes "dim_vec b = dim_row T"
shows "b \<notin> set_cols (delete_col T b)"
unfolding delete_col 
by (metis (mono_tags, lifting) cols_dim cols_mat_of_cols dual_order.trans filter_is_subset 
filter_set member_filter set_cols)

lemma dim_col_distinct:
assumes "distinct (cols S)" 
shows "card (set_cols S) = dim_col S"
by (simp add: assms distinct_card)

lemma set_cols_mono:
assumes "set_cols S \<subseteq> set_cols T" "distinct (cols S)" "distinct (cols T)"
shows "dim_col S \<le> dim_col T"
using assms 
by (metis List.finite_set card_mono dim_col_distinct set_cols)

lemma set_cols_insert_col:
assumes "dim_vec b = dim_row U"
shows "set_cols (insert_col U b) = set_cols U \<union> {b}"
by (metis (no_types, opaque_lifting) Un_commute Un_insert_right assms carrier_vec_dim_vec 
  cols_dim cols_mat_of_cols insert_col insert_subset list.set(2) set_cols sup_bot.left_neutral)

lemma exchange_lemma:
  assumes i: "is_indep S"
    and sp: "set_cols S \<subseteq> span T"
    and d: "distinct (cols T)"
  shows "\<exists>t'. dim_col t' = dim_col T \<and> set_cols S \<subseteq> set_cols t' \<and> 
              set_cols t' \<subseteq> set_cols S \<union> set_cols T \<and> distinct (cols t')"
(*need "distinct (cols t')*)
  using i sp d
proof (induct "card (set_cols T - set_cols S)" arbitrary: S T rule: less_induct)
  case less
  have ft: "finite (set_cols T)" by auto
  note S = \<open>is_indep S\<close>
  let ?P = "\<lambda>t'. dim_col t' = dim_col T \<and> set_cols S \<subseteq> set_cols t' \<and> 
              set_cols t' \<subseteq> set_cols S \<union> set_cols T \<and> distinct (cols t')"
  show ?case
  proof (cases "set_cols S \<subseteq> set_cols T  \<or> set_cols T \<subseteq> set_cols S")
    case True
    then show ?thesis
    proof
      assume "set_cols S \<subseteq> set_cols T"
      then show ?thesis using less.prems(3) by auto
    next
      assume "set_cols T \<subseteq> set_cols S" then show ?thesis
       using spanning_subset_independent[OF _ S ] less.prems(3) less.prems(2) by blast
    qed
  next
    case False
    then have st: "\<not> set_cols S \<subseteq> set_cols T" "\<not> set_cols T \<subseteq> set_cols S"
      by auto
    from st(2) obtain b where b: "b \<in> set_cols T" "b \<notin> set_cols S"
      by blast
    from b have "set_cols T - {b} - (set_cols S) \<subset> set_cols T - set_cols S"
      by blast
    then have cardlt: "card (set_cols T - {b} - set_cols S) < card (set_cols T - set_cols S)"
      using ft by (auto intro: psubset_card_mono)
    from b ft have ct0: "card (set_cols T) \<noteq> 0"
      by auto
    let ?T_b = "delete_col T b"
    from ft have ftb: "finite (set_cols ?T_b)"
      by auto
    have dim_col_T_gr_0: "dim_col T > 0" using b(1) 
    by (metis atLeastLessThan_iff bot_nat_0.not_eq_extremum cols_def imageE list.set_map 
      set_cols set_upt zero_order(3))
    have dim_col_T_b: "dim_col ?T_b = dim_col T - 1" 
    proof -
      have "length (cols T) > 0" using dim_col_T_gr_0 unfolding cols_length by auto
      have "length (filter (\<lambda>x. x = b) (cols T)) = 1" 
      proof -
        have "length (filter (\<lambda>x. x = b) (cols T)) = 
          card {i. i < dim_col T \<and> col T i = b}"
          unfolding length_filter_conv_card using cols_nth by (metis cols_length) 
        then show ?thesis using less.prems(3) \<open>b \<in> set_cols T\<close>
        by (smt (verit, del_insts) Collect_cong List.finite_set One_nat_def card.empty 
          card.insert distinct_card distinct_filter equals0D list.set(1) set_cols set_filter 
          singleton_conv)
      qed
      then have "length (filter (\<lambda>x. x \<noteq> b) (cols T)) = length (cols T) - 1" 
         using sum_length_filter_compl by (metis add_diff_cancel_left') 
      then show ?thesis unfolding delete_col by auto
    qed
    have "dim_vec b = dim_row T" 
      using b(1) carrier_dim_vec cols_dim set_cols by blast
    have set_cols_T_b: "set_cols ?T_b = set_cols T - {b}"
    proof -
      have "set_cols ?T_b \<subseteq> set_cols T" 
      by (smt (verit) cols_dim cols_mat_of_cols delete_col filter_is_subset order_trans set_cols)
      moreover have "b \<notin> set_cols ?T_b" using \<open>dim_vec b = dim_row T\<close>
        by (subst delet_col_not_in_set_cols, auto)
      ultimately show ?thesis
      by (smt (verit, ccfv_SIG) Diff_insert_absorb Diff_subset_conv Suc_pred' Un_absorb1 b(1) 
      card.insert cols_dim cols_mat_of_cols delete_col dim_col_T_b dim_col_T_gr_0 dim_col_distinct 
      distinct_filter filter_is_subset ft ftb inf_sup_ord(4) insert_Diff insert_union less.prems(3) 
      less_not_refl2 order_trans psubsetI psubset_card_mono)
    qed
    show ?thesis
    proof (cases "set_cols S \<subseteq> span (?T_b)")
      case True
      from cardlt have cardlt': "card (set_cols (?T_b) - set_cols S) < 
        card (set_cols T - set_cols S)"
        using set_cols_T_b by auto
      have "distinct (cols (delete_col T b))" using less.prems(3)
      by (metis cols_dim cols_mat_of_cols delete_col distinct_filter filter_is_subset order_trans)
      then obtain U where U: "dim_col U = dim_col ?T_b" "set_cols S \<subseteq> set_cols U" 
        "set_cols U \<subseteq> set_cols S \<union> set_cols (?T_b)" "distinct (cols U)"
      using less(1)[OF cardlt' S True] by blast
      let ?w = "insert_col U b"
      have dim_col_w: "dim_col ?w = dim_col U + 1" unfolding insert_col by simp
      have "dim_row T = dim_row S" using False 
      by (smt (verit, ccfv_threshold) Lattice_int.span_def True carrier_vecD cols_dim delete_col 
        dim_mult_mat_vec insert_Diff insert_subset mat_of_cols_carrier(2) mem_Collect_eq set_cols 
        subsetI)
      have "dim_vec b = dim_row U" unfolding \<open>dim_vec b = dim_row T\<close> \<open>dim_row T = dim_row S\<close> 
        by (metis U(2) carrier_vecD cols_dim set_cols st(1) subset_iff) 
      then have set_cols_w: "set_cols ?w = set_cols U \<union> {b}" 
        by (subst set_cols_insert_col, auto) 
      have th0: "set_cols S \<subseteq> set_cols ?w"
        using U(2) set_cols_w by auto
      have th1: "set_cols ?w \<subseteq> set_cols S \<union> set_cols T"
        using U b set_cols_w set_cols_T_b by auto
      have bu: "b \<notin> set_cols U"
        using b U 
        by (metis DiffD2 Un_iff insertCI set_cols_T_b sup.orderE)
      from U(1) have "dim_col U = dim_col T - 1"
      using dim_col_T_b by presburger
      then have th2: "dim_col (?w) = dim_col T" unfolding dim_col_w 
      using dim_col_T_gr_0 by linarith
      have th3: "distinct (cols ?w)"
      proof -
        have "b \<notin> set_cols U" using bu by blast 
        then show ?thesis 
        by (metis List.finite_set Suc_pred' U(4) \<open>dim_col U = dim_col T - 1\<close> card_distinct 
          card_insert_disjoint cols_length dim_col_T_gr_0 dim_col_distinct insert_union set_cols 
          set_cols_w th2)
      qed
      from th0 th1 th2 th3  have th: "?P ?w" by blast
      from th show ?thesis by blast
    next
      case False
      then obtain a where a: "a \<in> set_cols S" "a \<notin> span (?T_b)"
        by blast
      have ab: "a \<noteq> b"
        using a b by blast
      have at: "a \<notin> set_cols T"
        using a ab span_base[of a "?T_b"]
        by (metis DiffI empty_iff insert_iff set_cols_T_b)
      let ?insert_a =  "insert_col ?T_b a"
      have set_cols_insert: "set_cols ?insert_a = {a} \<union> set_cols ?T_b" 
      by (smt (verit, ccfv_SIG) Lattice_int.span_def Un_commute a(1) delete_col dim_mult_mat_vec 
        less.prems(2) mat_of_cols_carrier(2) mem_Collect_eq set_cols_insert_col subsetD)
      have dim_col_insert_a: "dim_col (?insert_a) = dim_col T" 
      by (metis One_nat_def Suc_eq_plus1_left Suc_pred' add.commute cols_length dim_col_T_b 
        dim_col_T_gr_0 insert_col list.size(4) mat_of_cols_carrier(3))
      have mlt: "card (set_cols ?insert_a - set_cols S) < card (set_cols T - set_cols S)"
        using cardlt a b
        by (metis insert_Diff1 insert_is_Un set_cols_T_b set_cols_insert)
      have sp': "set_cols S \<subseteq> span (?insert_a)"
      proof
        fix x
        assume xs: "x \<in> set_cols S"
        let ?insert_b =  "mat_of_cols (dim_row T) (b # cols ?insert_a)"
        have T: "set_cols T \<subseteq> set_cols ?insert_b"
          using b 
          by (smt (verit, ccfv_SIG) cols_dim cols_mat_of_cols delete_col dual_order.refl 
            insert_Diff insert_col insert_is_Un insert_subset list.set(2) mat_of_cols_carrier(2) 
            set_cols set_cols_T_b set_cols_insert)
        have bs: "b \<in> span (?insert_a)" 
        by (meson Lattice_int.in_span_delete a(1) a(2) in_mono less.prems(2))
        from xs sp have "x \<in> span T" using less.prems(2) by blast
        with span_mono[OF T] have x: "x \<in> span (?insert_b)" by auto
        from span_trans show "x \<in> span (?insert_a)" 
        by (metis bs delete_col insert_col mat_of_cols_carrier(2) x)
      qed
      from less(1)[OF mlt S sp'] obtain U where U:
        "dim_col U = dim_col (insert_col (?T_b) a)"
        "set_cols S \<subseteq> set_cols U" "set_cols U \<subseteq> set_cols S \<union> set_cols (insert_col (?T_b) a)"
        "distinct (cols U)" 
        by (metis Diff_not_in Lattice_int.span_base a(2) b(1) card_distinct card_insert_disjoint 
          cols_length dim_col_distinct dim_col_insert_a ftb insert_Diff insert_is_Un 
          less.prems(3) set_cols set_cols_T_b set_cols_insert)
      from U a b ft at ct0 have "?P U" 
      using dim_col_insert_a set_cols_T_b set_cols_insert by auto
      then show ?thesis by blast
    qed
  qed
qed



lemma independent_span_bound:
  assumes i: "is_indep S" and d: "distinct (cols T)"
    and sp: "set_cols S \<subseteq> span T"
  shows "dim_col S \<le> dim_col T"
proof -
  obtain t' where t: "dim_col t' = dim_col T"
       "set_cols S \<subseteq> set_cols t'"
       "set_cols t' \<subseteq> set_cols S \<union> set_cols T" 
       "distinct (cols t')"
  using exchange_lemma[OF i sp d] by blast
  then have "dim_col S \<le> dim_col t'" 
    using assms is_indep_distinct[OF i] is_indep_distinct[OF i] by (subst set_cols_mono, auto)
  then show ?thesis using t(1) by auto
qed


lemma gen_lattice_in_span:
assumes "gen_lattice B = gen_lattice B'"
shows "set_cols B \<subseteq> Lattice_int.span B'"
unfolding gen_lattice_def
by (smt (verit, ccfv_SIG) Lattice_int.span_base Lattice_int.span_def assms gen_lattice_def subsetI)

(* A general change of basis theorem is missing, corollary: all bases have the same length *)
lemma basis_exchange:
  assumes gen_eq: "gen_lattice B = gen_lattice B'" and "is_indep B" and "is_indep B'"
  shows "dim_col B = dim_col B'"
proof -
  have "dim_col B \<le> dim_col B'" 
    using assms(2) is_indep_distinct[OF assms(3)] gen_lattice_in_span[OF assms(1)] 
    by (subst independent_span_bound, auto)
  moreover have "dim_col B' \<le> dim_col B" 
    using assms(3) is_indep_distinct[OF assms(2)] gen_lattice_in_span[OF assms(1)[symmetric]] 
    by (subst independent_span_bound, auto)
  ultimately show ?thesis by linarith
qed




























context vec_space
begin
definition lin_indpt_vec :: "'a mat \<Rightarrow>  bool" where
  "lin_indpt_vec A = lin_indpt (set (cols A))"

definition span_vec :: "'a mat \<Rightarrow> 'a vec set" where
  "span_vec A = span (set (cols A))"
end

definition span_vec :: "('a::semiring_1) mat \<Rightarrow> 'a vec set" where
  "span_vec \<equiv> (\<lambda>B. LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row B)) 
  (set (cols B)))"

definition lin_indpt_vec :: "('a::semiring_1) mat \<Rightarrow> bool" where
  "lin_indpt_vec A \<equiv> module.lin_indpt class_ring (module_vec TYPE('a) (dim_row A))
          (set (cols A))"

value "vec_space.lin_indpt_vec n A "


lemma "lin_indpt_vec A = is_indep A"
proof (safe, goal_cases)
  case 1
  then show ?case unfolding lin_indpt_vec_def  sorry
next
  case 2
  then show ?case sorry
qed
  assume assms: "lin_indpt_vec A"
  then have "\<not> module.lin_dep class_ring (module_vec TYPE(int) (dim_row A)) (set (cols A))" 
    unfolding module.lin_dep_def
  show "is_indep A" using assms unfolding lin_indpt_vec_def module.lin_dep_def   sorry
next
  assume "is_indep A"
  show"lin_indpt_vec A" sorry
qed

lemma  gen_lattice_span_int:
  "span_vec ( B) = LinearCombinations.module.span class_ring (module_vec TYPE(int) (dim_row B)) 
    (gen_lattice B)"
sorry

lemma basis_exchange:
  assumes gen_eq: "gen_lattice B = gen_lattice B'" and "is_indep B" and "is_indep B'"
  shows "dim_col B = dim_col B'"
proof -
  define nr where "nr = dim_row B"
  have "dim_row B = dim_row B'" sorry
  have "vec_space.lin_indpt_vec nr (real_of_int_mat B)" sorry
  have "vec_space.lin_indpt_vec nr (real_of_int_mat B')" sorry
  have "vec_space.span_vec nr (real_of_int_mat B) = vec_space.span_vec nr (real_of_int_mat B')"
    using gen_eq unfolding vec_space.span_vec_def sorry
  have "vec_space.rank nr (real_of_int_mat B) = vec_space.rank nr (real_of_int_mat B')" sorry
qed











definition type_ring :: "'a :: ring_1 itself \<Rightarrow> 'a ring" where
  "type_ring _ = \<lparr>carrier = UNIV, mult = (*), one = 1, zero = 0, add = (+)\<rparr>"

lemma type_ring_simps [simp]:
  "carrier (type_ring ty) = UNIV"
  "mult (type_ring ty) = (*)"
  "one (type_ring ty) = 1"
  "zero (type_ring ty) = 0"
  "add (type_ring ty) = (+)"
  by (auto simp: type_ring_def)

lemma Units_type_cring: "Units (type_ring (ty :: 'a :: comm_ring_1 itself)) = {x. x dvd 1}"
  unfolding Units_def by (auto simp: algebra_simps dvd_def)

lemma Units_type_field [simp]: "Units (type_ring (ty :: 'a :: field itself)) = -{0}"
  unfolding Units_type_cring by (auto simp: dvd_field_iff)

interpretation type_ring: ring "type_ring TYPE('a :: ring_1)"
  by standard (auto simp: algebra_simps Units_def add_eq_0_iff)

interpretation type_cring: cring "type_ring TYPE('a :: comm_ring_1)"
  by standard (auto simp: algebra_simps)

interpretation type_field: field "type_ring TYPE('a :: field)"
  by standard auto

interpretation vec_mod: Module.module "type_ring TYPE('a :: comm_ring_1)" "module_vec TYPE('a) n" for n
  by standard
     (use add_inv_exists_vec in \<open>auto simp: module_vec_simps algebra_simps comm_add_vec Units_def\<close>)

interpretation vec: vectorspace "type_ring TYPE('a :: field)" "module_vec TYPE('a) n"
  ..



lemma dim_carrier: "dim_vec z = dim_col A \<Longrightarrow> A *\<^sub>v z \<in> carrier_vec (dim_row A)"
  by (metis carrier_vec_dim_vec dim_mult_mat_vec)


text \<open>Concrete type conversion int vec to real vec\<close>
definition real_of_int_vec :: "int vec \<Rightarrow> real vec"  where
  "real_of_int_vec v = map_vec real_of_int v"

definition real_to_int_vec :: "real vec \<Rightarrow> int vec"  where
  "real_to_int_vec v = map_vec floor v"


lemma[simp]: "dim_vec (real_of_int_vec v) = dim_vec v" 
  unfolding real_of_int_vec_def by auto

lemma real_of_int_vec_nth[simp, intro]: 
  "i<dim_vec v \<Longrightarrow> (real_of_int_vec v) $ i = real_of_int (v$i)"
by (simp add: real_of_int_vec_def)

lemma real_of_int_vec_vec:
  "real_of_int_vec (vec n f) = vec n (real_of_int \<circ> f)"
by (auto simp add: real_of_int_vec_def)

text \<open>Concrete type conversion int mat to real mat\<close>
definition real_of_int_mat :: "int mat \<Rightarrow> real mat"  where
  "real_of_int_mat A = map_mat real_of_int A"

definition real_to_int_mat :: "real mat \<Rightarrow> int mat"  where
  "real_to_int_mat A = map_mat floor A"


lemma[simp]: "dim_col (real_of_int_mat A) = dim_col A" 
  unfolding real_of_int_mat_def by auto

lemma[simp]: "dim_row (real_of_int_mat A) = dim_row A" 
  unfolding real_of_int_mat_def by auto

lemma real_of_int_mat_nth[simp, intro]: 
  "i<dim_row A \<Longrightarrow> j<dim_col A \<Longrightarrow> (real_of_int_mat A) $$ (i,j) = real_of_int (A $$ (i,j))"
by (simp add: real_of_int_mat_def)

lemma real_of_int_mat_mat:
  "real_of_int_mat (mat n m f) = mat n m (real_of_int \<circ> f)"
by (auto simp add: real_of_int_mat_def)


text \<open>Algebraic lattices are discrete additive subgroups of $\mathbb{R}^n$.
  Lattices can be represented by a basis, multiple bases can represent the same lattice.\<close>
type_synonym int_lattice = "int vec set"

(*
definition mat_mult_to_coeffs :: "'b mat \<Rightarrow> 'a vec \<Rightarrow> 'b vec \<Rightarrow> 'a" where
  "mat_mult_to_coeffs A b a = (b $ (THE i. col A i = a))"

lemma dim_vec_lincomb: "dim_vec (vec_mod.lincomb n a b) = n"
unfolding vec_mod.lincomb_def sorry  
  
lemma mat_mult_lincomb:
assumes "dim_vec b = dim_col A"   
shows "A *\<^sub>v b = vec_mod.lincomb (dim_row A) (mat_mult_to_coeffs A b) (set (cols A))"
  (is "?left = ?right")
proof (subst eq_vecI[of ?left ?right], goal_cases)
  case (1 i)
  then show ?case unfolding mat_mult_to_coeffs_def mult_mat_vec_def vec_mod.lincomb_def 
    sorry
next
  case 2
  then show ?case using assms using dim_vec_lincomb by auto
qed auto
*)

text \<open>A lattice basis is a linearly independent set of vectors whose integer span is the lattice.\<close>

(*
definition is_indep :: "int mat \<Rightarrow> bool" where
  "is_indep A \<equiv> vec_mod.lin_indpt (dim_row A) (set (cols A))"

*)

(*L is integer span of B and vectors in B are linearly independent*)
definition is_indep :: "int mat \<Rightarrow> bool" where
  "is_indep A \<equiv> (\<forall>z::real vec. (real_of_int_mat A *\<^sub>v z = 0\<^sub>v (dim_row A) \<and> 
    dim_vec z = dim_col A) \<longrightarrow> z = 0\<^sub>v (dim_vec z))"
 
(*
lemma is_indep_distinct_cols:
  "is_indep A \<Longrightarrow> distinct (cols A)"
proof (rule ccontr)
  assume "is_indep A" "\<not> distinct (cols A)"
  then obtain i j where "i\<noteq>j" "col A i = col A j" "i<dim_col A" "j<dim_col A"
  by (metis cols_length cols_nth distinct_conv_nth)
  define z :: "real vec" where 
    "z = vec (dim_col A) (\<lambda>k. if k = i then 1 else (if k = j then -1 else 0))"
  then have "A *\<^sub>v z = 0\<^sub>v (dim_row A)" 
  proof (subst eq_vecI[of "A *\<^sub>v z" "0\<^sub>v (dim_row A)"], goal_cases)
    case (1 k)
    have "vec (dim_row A) (\<lambda>l. row A l \<bullet> z) $ k = row A k \<bullet> z"
      using "1"(2) by auto
    also have "\<dots> = (\<Sum>ia = 0..<dim_col A.
        row A k $ ia * (if ia = i then 1 else if ia = j then - 1 else 0))"
      unfolding scalar_prod_def z_def by auto 
    also have "\<dots> = row A k $ i - row A k $ j"  sorry
    also have "\<dots> = A $$ (k,i) - A $$ (k,j)" using index_row(1)
      by (metis "1"(2) \<open>i < dim_col A\<close> \<open>j < dim_col A\<close> dim_mult_mat_vec)
    also have "\<dots> = 0" using \<open>col A i = col A j\<close>
      using "1"(2) \<open>i < dim_col A\<close> \<open>j < dim_col A\<close> index_col by fastforce
    finally have "vec (dim_row A) (\<lambda>l. row A l \<bullet> z) $ k = 0" by auto
    then show ?case unfolding mult_mat_vec_def using 1 by auto
  qed auto
  moreover have "dim_vec z = dim_col A" unfolding z_def by auto
  ultimately have z_eq_0:  "z = 0\<^sub>v (dim_vec z)" using \<open>is_indep A\<close> unfolding is_indep_def by auto
  have "z $ i = 0" using z_eq_0 index_zero_vec(1)[OF \<open>i<dim_col A\<close>] 
  unfolding \<open>dim_vec z = dim_col A\<close> by auto
  moreover have "z $ i = 1" unfolding z_def by (simp add: \<open>i < dim_col A\<close>)
  ultimately show False by auto  
qed

  
lemma is_indep :
  "is_indep A = vec_mod.lin_indpt (dim_row A) (set (cols A))"
proof (safe, goal_cases)
  case 1
  have "distinct (cols A)" using is_indep_distinct_cols[OF \<open>is_indep A\<close>] by auto
  obtain Aa a v where props:
    "finite Aa"
    "Aa \<subseteq> set (cols A)"
    "a \<in> Aa \<rightarrow> carrier (type_ring TYPE(real))"
    "vec_mod.lincomb (dim_row A) a Aa = 0\<^sub>v (dim_row A)"
    "v \<in> Aa"
    "a v \<noteq> 0"
    using 1(2) unfolding vec_mod.lin_dep_def 
    by (metis module_vec_simps(2) type_ring_simps(4))
  define z where "z = vec (dim_col A) (\<lambda>i. if col A i \<in> Aa then a (col A i) else 0)"
  have "dim_vec z = dim_col A " unfolding z_def by auto
  moreover have "A *\<^sub>v z = 0\<^sub>v (dim_row A)"
  proof -
    show ?thesis 
    proof (subst eq_vecI[of "A *\<^sub>v z" "0\<^sub>v (dim_row A)"], goal_cases)
      case (1 i)
      then show ?case  unfolding z_def mult_mat_vec_def sorry
    qed auto
  qed




  obtain Aa_list where Aa_list_def: "set Aa_list = Aa" "distinct Aa_list" 
    using finite_list[OF \<open>finite Aa\<close>] props(2) \<open>distinct (cols A)\<close> 
    by (metis set_obtain_sublist)
  define nc where "nc = length Aa_list"
  define a_list where "a_list = (\<lambda>i. a (Aa_list ! i))"
  have rewrite: "vec_mod.lincomb (dim_row A) a Aa = 
    mat_of_cols (dim_row A) (Aa_list) *\<^sub>v (vec nc a_list)"
   sorry
  obtain z where z_def:
    "mat_of_cols (dim_row A) (Aa_list) *\<^sub>v (vec nc a_list) = A *\<^sub>v z" "dim_vec z = (dim_col A)"
  using helper3[of A "dim_row A" "dim_col A" Aa_list "vec nc a_list"]
  by (subst helper3[of A "dim_row A" "dim_col A" Aa_list "vec nc a_list"],
    auto simp add: props Aa_list_def nc_def)
  have *: "A *\<^sub>v z =  0\<^sub>v (dim_row A)" unfolding z_def(1)[symmetric] rewrite[symmetric] 
    using props(4) by auto
  have "z = 0\<^sub>v (dim_col A)" using 1(1) unfolding is_indep_def using  * z_def(2)
    by auto
  then have z_zero: "z $ i = 0" if "i<dim_col A" for i
  using index_zero_vec(1) that by blast
  have "\<exists>i. i<dim_col A \<and> col A i = v" 
  proof -
    have "v\<in>set (cols A)" using props by auto
    then show ?thesis
    by (metis (mono_tags, opaque_lifting) atLeastLessThan_iff cols_def imageE list.set_map set_upt)
  qed
  then obtain i where "i<dim_col A" "col A i = v" 
    by blast
  then have "z$i = a v" using z_def props sorry
  then have "a v = 0" using z_zero[of i] \<open>i<dim_col A\<close> by auto
  then show False using props(6) by auto
next
  case (2)
  then show ?case unfolding is_indep_def 
  proof (safe, goal_cases)
    case (1 z)
    then show ?case sorry
  qed
qed

*)
    

definition is_lattice :: "int_lattice \<Rightarrow> bool" where
  "is_lattice L \<equiv> (\<exists>B::(int mat). 
    L = {B *\<^sub>v z | z::int vec. dim_vec z = dim_col B} 
    \<and> is_indep B)"

    


text \<open>The lattice generated by the column vectors of a matrix. 
  This matrix does not need to be linearly independent. 
  Make certain that the output is indeed a lattice and not the entire space.\<close>
definition gen_lattice :: "int mat \<Rightarrow> int vec set" where
  "gen_lattice A = {A *\<^sub>v z | z::int vec. dim_vec z = dim_col A}"

interpretation lattice_mod: submodule "type_ring TYPE(int)" 
  "gen_lattice A" "module_vec TYPE(int) (dim_row A)" for A
proof (standard, goal_cases)
  case 1
  show ?case by (auto simp add: gen_lattice_def Matrix.module_vec_simps(3) dim_carrier)
next
  case (2 v w)
  obtain zv :: "int vec" where "v = A *\<^sub>v zv" and "dim_vec zv = dim_col A" 
    using 2(1) unfolding gen_lattice_def by blast
  obtain zw :: "int vec" where "w = A *\<^sub>v zw" and "dim_vec zw = dim_col A" 
    using 2(2) unfolding gen_lattice_def by blast
  have "v + w = A *\<^sub>v (zv + zw)" unfolding \<open>v = A *\<^sub>v zv\<close> \<open>w = A *\<^sub>v zw\<close>
    by (metis \<open>dim_vec zv = dim_col A\<close> \<open>dim_vec zw = dim_col A\<close> carrier_mat_triv 
        carrier_vec_dim_vec mult_add_distrib_mat_vec)
  moreover have "dim_vec (zv + zw) = dim_col A"
    by (simp add: \<open>dim_vec zw = dim_col A\<close>)
  ultimately show ?case unfolding gen_lattice_def
    by (metis (mono_tags, lifting) mem_Collect_eq module_vec_simps(1))
next
  case 3
  have "0\<^sub>v (dim_row A) \<in> gen_lattice A"
    by (smt (verit, best) carrier_matI dim_mult_mat_vec gen_lattice_def index_transpose_mat(2) 
        index_transpose_mat(3) mem_Collect_eq minus_cancel_vec mult_mat_vec_carrier 
        mult_minus_distrib_mat_vec zero_carrier_vec)
  then show ?case 
    by (simp add: module_vec_simps(2))
next
  case (4 c v)
  obtain z :: "int vec" where "v = A *\<^sub>v z" and "dim_vec z = dim_col A" 
    using 4(2) unfolding gen_lattice_def by blast
  then have "c \<cdot>\<^sub>v v = A *\<^sub>v (c \<cdot>\<^sub>v z)" and "dim_vec (c \<cdot>\<^sub>v z) = dim_col A" by auto
  then show ?case unfolding gen_lattice_def
    by (metis (mono_tags, lifting) mem_Collect_eq module_vec_simps(4))
qed 

lemma "module (type_ring TYPE(int)) (vec_mod.md (dim_row A) (gen_lattice A))"
  using lattice_mod.submodule_axioms vec_mod.submodule_is_module by blast

text \<open>But we can always find a linearly independent matrix, that spans the same lattice 
  (if the lattice is not the entire space).\<close>


definition basis_of :: "int vec set \<Rightarrow> int mat" where
  "basis_of L = (SOME B. L = gen_lattice B \<and> is_indep B)"

(* A general change of basis theorem is missing, corollary: all bases have the same length *)
lemma basis_exchange:
  assumes "gen_lattice B = gen_lattice B'" and "is_indep B" and "is_indep B'"
  shows "dim_col B = dim_col B'"
proof -
  
qed
  
  


text \<open>The dimension of the lattice is the same for all possible bases -> Show this!\<close>
definition dim_lattice :: "int_lattice \<Rightarrow> nat" where
  "dim_lattice L = (THE x. x = dim_col (basis_of L))"

lemma dim_lattice_gen_lattice:
  assumes "is_indep B"
  shows "dim_lattice (gen_lattice B) = dim_col B"
unfolding dim_lattice_def using assms basis_exchange[of "basis_of (gen_lattice B)" B] 
  by (auto simp add: basis_of_def)(metis (mono_tags, lifting) assms tfl_some)



text \<open>A lattice generated by a linearly independent matrix is indeed a lattice.\<close>
lemma is_lattice_gen_lattice:
  assumes "is_indep A"
  shows "is_lattice (gen_lattice A)"
unfolding is_lattice_def gen_lattice_def using assms by auto


(*linf_norm aus afp/LLL_Basis_Reduction*)



end