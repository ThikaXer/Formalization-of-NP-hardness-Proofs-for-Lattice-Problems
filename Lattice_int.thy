theory Lattice_int

imports "Jordan_Normal_Form.Matrix"
        "Jordan_Normal_Form.VS_Connect"
        "BenOr_Kozen_Reif.More_Matrix"

begin

text \<open>Connect the type vec to records of rings, commutative rings, fields and modules in order to
  use properties of modules such as lin_indpt (linear independence).\<close>


lemma dim_carrier: "dim_vec z = dim_col A \<Longrightarrow> A *\<^sub>v z \<in> carrier_vec (dim_row A)"
  by (metis carrier_vec_dim_vec dim_mult_mat_vec)


text \<open>Concrete type conversion int vec to real vec\<close>
definition real_of_int_vec :: "int vec \<Rightarrow> real vec"  where
  "real_of_int_vec v = map_vec real_of_int v"

definition real_to_int_vec :: "real vec \<Rightarrow> int vec"  where
  "real_to_int_vec v = map_vec floor v"


lemma[simp]: "dim_vec (real_of_int_vec v) = dim_vec v" 
  unfolding real_of_int_vec_def by auto

lemma real_of_int_vec_nth[simp, intro]: 
  "i<dim_vec v \<Longrightarrow> (real_of_int_vec v) $ i = real_of_int (v$i)"
by (simp add: real_of_int_vec_def)

lemma real_of_int_vec_vec:
  "real_of_int_vec (vec n f) = vec n (real_of_int \<circ> f)"
by (auto simp add: real_of_int_vec_def)

text \<open>Concrete type conversion int mat to real mat\<close>
definition real_of_int_mat :: "int mat \<Rightarrow> real mat"  where
  "real_of_int_mat A = map_mat real_of_int A"

definition real_to_int_mat :: "real mat \<Rightarrow> int mat"  where
  "real_to_int_mat A = map_mat floor A"


lemma[simp]: "dim_col (real_of_int_mat A) = dim_col A" 
  unfolding real_of_int_mat_def by auto

lemma[simp]: "dim_row (real_of_int_mat A) = dim_row A" 
  unfolding real_of_int_mat_def by auto

lemma real_of_int_mat_nth[simp, intro]: 
  "i<dim_row A \<Longrightarrow> j<dim_col A \<Longrightarrow> (real_of_int_mat A) $$ (i,j) = real_of_int (A $$ (i,j))"
by (simp add: real_of_int_mat_def)

lemma real_of_int_mat_mat:
  "real_of_int_mat (mat n m f) = mat n m (real_of_int \<circ> f)"
by (auto simp add: real_of_int_mat_def)


text \<open>Algebraic lattices are discrete additive subgroups of $\mathbb{R}^n$.
  Lattices can be represented by a basis, multiple bases can represent the same lattice.\<close>
type_synonym int_lattice = "int vec set"

text \<open>Linear independence\<close>

definition is_indep :: "int mat \<Rightarrow> bool" where
  "is_indep A \<equiv> (\<forall>z::real vec. (real_of_int_mat A *\<^sub>v z = 0\<^sub>v (dim_row A) \<and> 
    dim_vec z = dim_col A) \<longrightarrow> z = 0\<^sub>v (dim_vec z))"


text \<open>properties of lattices\<close>

definition is_lattice :: "int_lattice \<Rightarrow> bool" where
  "is_lattice L \<equiv> (\<exists>B::(int mat). 
    L = {B *\<^sub>v z | z::int vec. dim_vec z = dim_col B} 
    \<and> is_indep B)"


text \<open>The lattice generated by the column vectors of a matrix. 
  This matrix does not need to be linearly independent. 
  Make certain that the output is indeed a lattice and not the entire space.\<close>
definition gen_lattice :: "int mat \<Rightarrow> int vec set" where
  "gen_lattice A = {A *\<^sub>v z | z::int vec. dim_vec z = dim_col A}"




text \<open>Theorems\<close>
lemma finsum_vec_carrier:
assumes "f ` A \<subseteq> carrier_vec nr" "finite A"
shows "finsum_vec TYPE('a::ring) nr f A \<in> carrier_vec nr" 
using assms unfolding finsum_vec_def
by (metis (no_types, lifting) Pi_I' comm_monoid.finprod_closed comm_monoid_vec 
  image_subset_iff monoid_vec_simps(2))

lemma dim_vec_finsum_vec:
assumes "f ` A \<subseteq> carrier_vec nr" "finite A"
shows "dim_vec (finsum_vec TYPE('a::ring) nr f A) = nr" 
using assms finsum_vec_carrier by (metis carrier_vecD)
    

lemma mat_mult_as_col_span:
assumes "(A :: 'a :: comm_ring mat) \<in> carrier_mat nr nc"
  and "(z :: 'a vec) \<in> carrier_vec nc"
shows "A *\<^sub>v z = finsum_vec TYPE('a) nr (\<lambda>i. z$i \<cdot>\<^sub>v col A i) {0..<nc}"
  (is "?left = ?right")
proof -
  have *: "finsum_vec TYPE('a) nr (\<lambda>i. z$i \<cdot>\<^sub>v col A i) {0..<nc} $ j = (A *\<^sub>v z) $ j" 
    if "j<nr" for j
  proof -
    have "finsum_vec TYPE('a) nr (\<lambda>i. z$i \<cdot>\<^sub>v col A i) {0..<nc} $ j = 
      sum (\<lambda>i. (z$i \<cdot>\<^sub>v col A i) $ j) {0..<nc}"
      by (subst index_finsum_vec, use assms that in \<open>auto\<close>)
    also have "\<dots> = sum (\<lambda>i. z$i * (col A i $ j)) {0..<nc}" 
      using assms(1) that by force
    also have "\<dots> = sum (\<lambda>i. z$i * A $$ (j,i)) {0..<nc}" using assms that by auto
    also have "\<dots> = sum (\<lambda>i. A $$ (j,i) * z$i) {0..<nc}"
      by (meson mult.commute)
    also have "\<dots> = sum (\<lambda>i. row A j $ i * z $ i) {0..<nc}" 
      using assms that by (auto simp add: index_row(1)[symmetric] simp del: index_row(1))
    also have "\<dots> = (A *\<^sub>v z) $ j" 
      unfolding mult_mat_vec_def scalar_prod_def using assms that by auto
    finally show ?thesis by blast
  qed
  then show ?thesis
  proof (subst eq_vecI[of ?left ?right], goal_cases)
    case (1 i)
    have dim_nr: "dim_vec (A *\<^sub>v z) = nr" 
      using assms(1) dim_mult_mat_vec by blast
    show ?case using assms 1 unfolding dim_nr by auto
  next
    case 2
    then show ?case using assms by (subst dim_vec_finsum_vec, auto)
  qed auto
qed

lemma mat_index:
"B = mat (dim_row B) (dim_col B) (\<lambda>(i,j). B $$ (i,j))"
by auto

lemma col_unit_vec:
assumes "i<dim_col (B:: 'a :: {monoid_mult, semiring_0, zero_neq_one} mat)"
shows "B *\<^sub>v (unit_vec (dim_col B) i) = col B i" (is "?left = ?right")
proof -
  have "B $$ (ia, i) = (\<Sum>ib = 0..<dim_col B. B $$ (ia, ib) * (if ib = i then 1 else 0))" 
    if "ia < dim_row B" for ia 
  proof -
    have "(\<Sum>ib = 0..<dim_col B. B $$ (ia, ib) * (if ib = i then 1 else 0)) =
      (\<Sum>ib = 0..<dim_col B. (if ib = i then B $$ (ia, ib) else 0))"
      by (smt (verit, best) mult.right_neutral mult_zero_right sum.cong)
    also have "\<dots> = B $$ (ia, i) +
       (\<Sum>ib\<in> {0..<dim_col B}-{i}. (if ib = i then B $$ (ia, ib) else 0))"
      by (simp add: assms)
    also have "\<dots> =  B $$ (ia, i)" by simp
    finally show ?thesis by auto
  qed
  then show ?thesis using assms by (subst eq_vecI[of ?left ?right]) 
    (auto simp add: unit_vec_def scalar_prod_def) 
qed

lemma is_indep_not_null:
assumes "is_indep B" "i<dim_col B"
shows "col B i \<noteq> 0\<^sub>v (dim_row B)"
proof (rule ccontr)
  assume "\<not> (col B i \<noteq> 0\<^sub>v (dim_row B))"
  then have "col B i = 0\<^sub>v (dim_row B)" by auto
  then have "real_of_int_mat B *\<^sub>v (unit_vec (dim_col B) i) = 0\<^sub>v (dim_row B)" 
  using col_unit_vec 
  by (metis assms(2) col_map_mat index_map_mat(3) of_int_hom.vec_hom_zero real_of_int_mat_def)
  moreover have "dim_vec (unit_vec (dim_col B) i) = dim_col B" by auto
  moreover have "(unit_vec (dim_col B) i) \<noteq> 0\<^sub>v (dim_col B)" 
    by (simp add: assms(2))
  ultimately have "\<not> (is_indep B)" unfolding is_indep_def by auto
  then show False using assms by auto
qed

lemma col_in_gen_lattice: 
assumes "i<dim_col B"
shows "col B i \<in> gen_lattice B"
unfolding gen_lattice_def proof (safe) 
  have "col B i = B *\<^sub>v (unit_vec (dim_col B) i)" using col_unit_vec[OF assms] by auto
  moreover have "dim_vec (unit_vec (dim_col B) i) = dim_col B" by auto
  ultimately show "\<exists>z. col B i = B *\<^sub>v z \<and> dim_vec z = dim_col B" by auto
qed

(* Lemmas for base change*)
definition span :: "('a :: semiring_0) mat \<Rightarrow> 'a vec set"  where
"span B = {B *\<^sub>v z | z:: 'a vec. dim_vec z = dim_col B}"

definition dim :: "int mat \<Rightarrow> nat" where 
"dim B = (if \<exists>b. is_indep b \<and> span (real_of_int_mat b) = span (real_of_int_mat B) then
    dim_col (SOME b. is_indep b \<and> span (real_of_int_mat b) = span (real_of_int_mat B)) else 0)"

definition set_cols[simp]: "set_cols A = set (cols A)"

definition insert_col:
"insert_col A c = mat_of_cols (dim_row A) (c # cols A)"

definition delete_col:
"delete_col A c = mat_of_cols (dim_row A) (filter (\<lambda> x. \<not> (x = c)) (cols A))"

lemma set_cols_col:
"set_cols A = col A ` {0..<dim_col A}"
by (simp add: cols_def)

lemma set_cols_subset_col:
assumes "set_cols A \<subseteq> set_cols B"
  "i<dim_col A"
obtains j where "col A i = col B j" 
proof -
  have "col A i \<in> set_cols B" using assms
    by (metis cols_length cols_nth nth_mem set_cols subsetD)
  then have "\<exists>j. col A i = col B j \<and> j<dim_col B"
    using set_cols_col by fastforce
  then show ?thesis using that by blast
qed


lemma is_indep_mono:
assumes "set_cols B \<subseteq> set_cols A" "is_indep A"
shows "is_indep B"
 sorry

lemma spanning_subset_independent:
assumes BA: "set_cols B \<subseteq> set_cols A" and iA: "is_indep A" and AsB:"set_cols A \<subseteq> span B" 
shows "set_cols A = set_cols B"
proof (intro antisym[OF _ BA] subsetI)
  have iB: "is_indep B" using is_indep_mono[OF BA iA] .
  fix v assume "v \<in> set_cols A"
  with AsB have "v \<in> span B" by auto
  then obtain zb where "v = B *\<^sub>v zb" "dim_vec zb = dim_col B" unfolding span_def by blast
  let ?RB = "representation B v" and ?RA = "representation A v"
  have "?RB v = 1"
    unfolding representation_extend[OF iA \<open>v \<in> span B\<close> BA, symmetric] 
    representation_basis[OF iA \<open>v \<in> A\<close>] by simp
  then show "v \<in> set_cols B"
    using representation_ne_zero[of B v v] by auto
qed

proof -
  have "set_cols A \<subseteq> set_cols B" sorry
  then show ?thesis
    using assms apply auto sorry
qed

lemma nth_lin_combo:
assumes "i < dim_row A" "dim_col A = dim_vec b"
shows "(A *\<^sub>v b) $ i = (\<Sum>j=0..<dim_col A. A $$ (i,j) * b $ j)"
using assms unfolding mult_mat_vec_def scalar_prod_def by auto

lemma span_mono:
assumes "set_cols A \<subseteq> set_cols B" "dim_row A = dim_row B"
shows "span A \<subseteq> span B"
sorry
(*
using assms proof (unfold span_def, safe, goal_cases)
  case (1 x z)
  show ?case 
  proof (cases "dim_col A = 0")
    case True
    then have "A *\<^sub>v z = B *\<^sub>v (0\<^sub>v (dim_col B))" 
      using "1"(5) assms(2) by auto
    then show ?thesis by auto
  next
    case False
(*    have "dim_row A = dim_row B" using assms
    proof -
      obtain i where i: "i<dim_col A" using False by auto
      obtain j where j: "col A i = col B j" using set_cols_subset_col[OF assms i] by blast
      have "dim_row A = dim_vec (col A i)" by auto
      also have "\<dots> = dim_vec (col B j)" using j by auto
      also have "\<dots> = dim_row B" by auto
      finally show ?thesis by auto
    qed*)
    define get_index where "get_index = (\<lambda>a. THE i. col A i = a)"
    define za where "za = vec (dim_col B) (\<lambda>i. if col B i \<in> set_cols A 
      then z $ (get_index (col B i)) else 0)"
    have "A *\<^sub>v z = B *\<^sub>v za" 
    proof (subst eq_vecI[of "A *\<^sub>v z" "B *\<^sub>v za"], goal_cases)
      case (1 i)
      have "(B *\<^sub>v za) $ i = (\<Sum>ia = 0..<dim_col B. B $$ (i, ia) * za $ ia)" 
        using "1" assms(2) nth_lin_combo za_def by fastforce
      also have "\<dots> = (\<Sum>ia \<in> {0..<dim_col B}\<inter>{ia. col B ia \<in> set_cols A}. B $$ (i, ia) * za $ ia) 
        + (\<Sum>ia \<in> {0..<dim_col B} - {ia. col B ia \<in> set_cols A}. B $$ (i, ia) * za $ ia)"
        by (subst sum.Int_Diff[of _ _ "{ia. col B ia \<in> set_cols A}"], auto)
      also have "\<dots> = (\<Sum>ia \<in> {0..<dim_col B}\<inter>{ia. col B ia \<in> set_cols A}. B $$ (i, ia) * za $ ia)"
        unfolding za_def by auto
      also have "\<dots> = (\<Sum>ia\<in>{0..<dim_col B} \<inter> {ia. col B ia \<in> set_cols A}.
       (if ia \<in> {ia. col B ia \<in> set_cols A} then B $$ (i, ia) * z $ get_index (col B ia) else 0))"
        unfolding za_def by auto
      also have "\<dots> = (\<Sum>ia \<in> {0..<dim_col B}\<inter>{ia. col B ia \<in> set_cols A}. B $$ (i, ia) * 
        z $ get_index (col B ia))"
        by (subst sum.inter_restrict[symmetric], auto)
      also have "\<dots> = (\<Sum>ib \<in> {ia. \<exists>j\<in>{0..<dim_col A}. col A j = col B ia}. 
        B $$ (i, ib) * z $ (get_index (col B ib)))" 
        (is "(\<Sum>ia \<in> ?S. ?f ia) = (\<Sum>ib \<in> ?T. ?g ib)") 
      proof -
        have "{0..<dim_col B}\<inter>{ia. col B ia \<in> set_cols A} = 
          {ia. ia<dim_col B \<and> (\<exists>j\<in>{0..<dim_col A}. col A j = col B ia)}" sorry
        then show ?thesis sorry by auto
      qed
(*(subst sum.reindex_bij_witness[where ?S = ?S and ?T = ?T and ?g = ?f and ?h = ?g], 
        auto, goal_cases)
        case (1 a)
        then show ?case 
        by (metis imageE set_cols set_cols_col)
      next
        case (2 b j)
        then show ?case sledgehammer sorry
      next
        case (3 b j)
        then show ?case sorry
      qed
*)

      also have "\<dots> = (\<Sum>j<dim_col A. A $$ (i,j) * z $ j)"  sorry
      also have "\<dots> = (A *\<^sub>v z) $ i" sorry
      finally show ?case by auto
    qed (use assms in \<open>auto\<close>)
    then have "\<exists>za. A *\<^sub>v z = B *\<^sub>v za \<and> dim_vec za = dim_col B"  sorry
    then show ?thesis sorry
qed 
*)


lemma span_base:
assumes "(a :: 'a :: {monoid_mult,semiring_0,zero_neq_one} vec) \<in> set_cols S"
shows "a \<in> span S"
proof -
  obtain i where "i<dim_col S" "a = col S i" using assms 
  by (metis atLeastLessThan_iff imageE set_cols_col)
  then have "a = S *\<^sub>v (unit_vec (dim_col S) i)" 
    using col_unit_vec[OF \<open>i<dim_col S\<close>, symmetric] by auto
  then show ?thesis unfolding span_def by auto
qed


lemma in_span_insert:
  assumes a: "a \<in> span (insert_col S b)"
    and na: "a \<notin> span S"
  shows "b \<in> span (insert_col S a)"
sorry
(*
proof -
  from span_breakdown[of b "insert b S" a, OF insertI1 a]
  obtain k where k: "a - k *s b \<in> span (S - {b})" by auto
  have "k \<noteq> 0"
  proof
    assume "k = 0"
    with k span_mono[of "S - {b}" S] have "a \<in> span S" by auto
    with na show False by blast  
  qed
  then have eq: "b = (1/k) *s a - (1/k) *s (a - k *s b)"
    by (simp add: algebra_simps)

  from k have "(1/k) *s (a - k *s b) \<in> span (S - {b})"
    by (rule span_scale)
  also have "... \<subseteq> span (insert a S)"
    by (rule span_mono) auto
  finally show ?thesis
    using k by (subst eq) (blast intro: span_diff span_scale span_base)
qed
*)
lemma insert_delete_span:
assumes "a \<in> set_cols A"
shows "span (insert_col (delete_col A a) a) = span (A)"
using assms unfolding insert_col delete_col apply auto  sorry

lemma delete_not_in_set_cols:
assumes "b \<notin> set_cols T"
shows "delete_col T b = T"
unfolding delete_col using assms  
by (metis (mono_tags, lifting) filter_True mat_of_cols_cols set_cols)

lemma delete_col_span:
assumes "a \<in> span (delete_col T b)"
shows "a \<in> span T"
using assms unfolding delete_col
by (metis (no_types, lifting) Lattice_int.span_mono cols_dim cols_mat_of_cols filter_is_subset 
  in_mono mat_of_cols_carrier(2) set_cols subset_trans)

lemma in_span_delete:
assumes "a \<in> span T" "a \<notin> span (delete_col T b)"
shows "b \<in> span (insert_col (delete_col T b) a)"
proof (subst in_span_insert[of a "delete_col T b" b], goal_cases)
  case 1
  then show ?case proof (cases "b\<in>set_cols T")
    case True
    then show ?thesis by (simp add: assms(1) insert_delete_span)
  next
    case False
    then show ?thesis by (metis assms(1) assms(2) delete_not_in_set_cols)
  qed 
qed (use assms in \<open>auto\<close>)

lemma mat_of_cols_mult_vCons:
assumes "dim_vec (x :: 'a ::comm_ring vec) = dim_row S" "dim_vec zs = dim_col S"
shows "mat_of_cols (dim_row S) (x # cols S) *\<^sub>v vCons z0 zs = z0 \<cdot>\<^sub>v x + S *\<^sub>v zs"
using assms carrier_vec_dim_vec[of zs] 
unfolding assms(2) by (subst mat_of_cols_cons_mat_vec, auto)

lemma mult_mat_vec_ring:
  assumes m: "(A::'a::comm_ring mat) \<in> carrier_mat nr nc" and v: "v \<in> carrier_vec nc"
  shows "A *\<^sub>v (k \<cdot>\<^sub>v v) = k \<cdot>\<^sub>v (A *\<^sub>v v)" (is "?l = ?r")
proof
  have nr: "dim_vec ?l = nr" using m v by auto
  also have "... = dim_vec ?r" using m v by auto
  finally show "dim_vec ?l = dim_vec ?r".
  show "\<And>i. i < dim_vec ?r \<Longrightarrow> ?l $ i = ?r $ i"
  proof -
    fix i assume "i < dim_vec ?r"
    hence i: "i < dim_row A" using nr m by auto
    hence i2: "i < dim_vec (A *\<^sub>v v)" using m by auto
    show "?l $ i = ?r $ i"
    apply (subst (1) mult_mat_vec_def)
    apply (subst (2) smult_vec_def)
    unfolding index_vec[OF i] index_vec[OF i2]
    unfolding mult_mat_vec_def smult_vec_def
    unfolding scalar_prod_def index_vec[OF i]
    by (simp add: mult.left_commute sum_distrib_left)
  qed
qed

lemma span_redundant:
assumes "(x :: 'a ::comm_ring vec) \<in> span S" 
shows "span (insert_col S x) = span S"
proof 
  have "\<exists>za. insert_col S x *\<^sub>v z = S *\<^sub>v za \<and> dim_vec za = dim_col S" 
    if "dim_vec z = dim_col (insert_col S x)" for z 
  proof -
    have dim_z: "dim_vec z = dim_col S + 1" using that by (simp add: insert_col)
    obtain za where za_def: "z = vCons (z$0) za"
    by (metis \<open>dim_vec z = dim_col (insert_col S x)\<close> add_Suc_right dim_vec insert_col list.size(4) 
      mat_of_cols_carrier(3) nat.simps(3) vec_cases vec_index_vCons_0)
    obtain zx where zx_def: "x = S *\<^sub>v zx" "dim_col S = dim_vec zx" 
      using assms unfolding span_def by auto
    have "dim_vec x = dim_row S" using zx_def(1) by auto 
    moreover have "dim_vec za = dim_col S" 
    by (metis Suc_eq_plus1_left add.commute add_diff_cancel_left' dim_vec_vCons dim_z za_def)
    ultimately have "insert_col S x *\<^sub>v z = z$0 \<cdot>\<^sub>v x + S *\<^sub>v za" 
      unfolding insert_col by (subst za_def, subst mat_of_cols_mult_vCons, auto)
    also have "\<dots> = z$0 \<cdot>\<^sub>v (S *\<^sub>v zx) + S *\<^sub>v za" unfolding zx_def by auto
    also have "\<dots> = S *\<^sub>v (z $ 0 \<cdot>\<^sub>v zx) + S *\<^sub>v za"
      by (subst mult_mat_vec_ring[symmetric]) (auto simp add: zx_def(2))
    also have "\<dots> = S *\<^sub>v (z$0 \<cdot>\<^sub>v zx + za)" 
      by (metis \<open>dim_vec za = dim_col S\<close> carrier_matI carrier_vec_dim_vec index_smult_vec(2) 
      mult_add_distrib_mat_vec zx_def(2))
    finally have "insert_col S x *\<^sub>v z = S *\<^sub>v (z$0 \<cdot>\<^sub>v zx + za)" by blast
    moreover have "dim_vec (z$0 \<cdot>\<^sub>v zx + za) = dim_col S" 
    by (metis Suc_eq_plus1_left add.commute add_diff_cancel_left' dim_vec_vCons dim_z 
      index_add_vec(2) za_def) 
    ultimately show ?thesis by blast
  qed
  then show "span (insert_col S x) \<subseteq> span S" unfolding span_def by auto
next 
  have "\<exists>za. S *\<^sub>v z = insert_col S x *\<^sub>v za \<and>
              dim_vec za = dim_col (insert_col S x)" if "dim_vec z = dim_col S" for z
  proof -
    define za where za_def: "za = vCons 0 z"
    have "dim_vec za = dim_col S + 1" using that za_def by force
    then have "dim_vec za = dim_col (insert_col S x)"
    by (simp add: insert_col)
    moreover have "S *\<^sub>v z = insert_col S x *\<^sub>v za" 
    proof -
      have "dim_vec x = dim_row S"
      using Lattice_int.span_def assms by force
      moreover have "dim_vec z = dim_col S" 
      using that by blast
      moreover have "S *\<^sub>v z = 0 \<cdot>\<^sub>v x + S *\<^sub>v z"
      using calculation(1) by auto
      ultimately show ?thesis unfolding insert_col za_def 
        by (subst mat_of_cols_mult_vCons)
    qed
    ultimately show ?thesis by blast
  qed
  then show "span S \<subseteq> span (insert_col S x)" unfolding span_def by auto
qed


lemma span_trans:
assumes "(x :: 'a ::comm_ring vec) \<in> span S" "y \<in> span (insert_col S x)"
shows "y \<in> span S"
using Lattice_int.span_redundant assms by blast

lemma is_indep_distinct:
assumes "is_indep A"
shows "distinct (cols A)"
 sorry

lemma delet_col_not_in_set_cols:
assumes "dim_vec b = dim_row T"
shows "b \<notin> set_cols (delete_col T b)"
unfolding delete_col 
by (metis (mono_tags, lifting) cols_dim cols_mat_of_cols dual_order.trans filter_is_subset 
filter_set member_filter set_cols)

lemma dim_col_distinct:
assumes "distinct (cols S)" 
shows "card (set_cols S) = dim_col S"
by (simp add: assms distinct_card)

lemma set_cols_mono:
assumes "set_cols S \<subseteq> set_cols T" "distinct (cols S)" "distinct (cols T)"
shows "dim_col S \<le> dim_col T"
using assms 
by (metis List.finite_set card_mono dim_col_distinct set_cols)

lemma set_cols_insert_col:
assumes "dim_vec b = dim_row U"
shows "set_cols (insert_col U b) = set_cols U \<union> {b}"
by (metis (no_types, opaque_lifting) Un_commute Un_insert_right assms carrier_vec_dim_vec 
  cols_dim cols_mat_of_cols insert_col insert_subset list.set(2) set_cols sup_bot.left_neutral)

lemma exchange_lemma:
  assumes i: "is_indep S"
    and sp: "set_cols S \<subseteq> span T"
    and d: "distinct (cols T)"
  shows "\<exists>t'. dim_col t' = dim_col T \<and> set_cols S \<subseteq> set_cols t' \<and> 
              set_cols t' \<subseteq> set_cols S \<union> set_cols T \<and> distinct (cols t')"
(*need "distinct (cols t')*)
  using i sp d
proof (induct "card (set_cols T - set_cols S)" arbitrary: S T rule: less_induct)
  case less
  have ft: "finite (set_cols T)" by auto
  note S = \<open>is_indep S\<close>
  let ?P = "\<lambda>t'. dim_col t' = dim_col T \<and> set_cols S \<subseteq> set_cols t' \<and> 
              set_cols t' \<subseteq> set_cols S \<union> set_cols T \<and> distinct (cols t')"
  show ?case
  proof (cases "set_cols S \<subseteq> set_cols T  \<or> set_cols T \<subseteq> set_cols S")
    case True
    then show ?thesis
    proof
      assume "set_cols S \<subseteq> set_cols T"
      then show ?thesis using less.prems(3) by auto
    next
      assume "set_cols T \<subseteq> set_cols S" then show ?thesis
       using spanning_subset_independent[OF _ S ] less.prems(3) less.prems(2) by blast
    qed
  next
    case False
    then have st: "\<not> set_cols S \<subseteq> set_cols T" "\<not> set_cols T \<subseteq> set_cols S"
      by auto
    from st(2) obtain b where b: "b \<in> set_cols T" "b \<notin> set_cols S"
      by blast
    from b have "set_cols T - {b} - (set_cols S) \<subset> set_cols T - set_cols S"
      by blast
    then have cardlt: "card (set_cols T - {b} - set_cols S) < card (set_cols T - set_cols S)"
      using ft by (auto intro: psubset_card_mono)
    from b ft have ct0: "card (set_cols T) \<noteq> 0"
      by auto
    let ?T_b = "delete_col T b"
    from ft have ftb: "finite (set_cols ?T_b)"
      by auto
    have dim_col_T_gr_0: "dim_col T > 0" using b(1) 
    by (metis atLeastLessThan_iff bot_nat_0.not_eq_extremum cols_def imageE list.set_map 
      set_cols set_upt zero_order(3))
    have dim_col_T_b: "dim_col ?T_b = dim_col T - 1" 
    proof -
      have "length (cols T) > 0" using dim_col_T_gr_0 unfolding cols_length by auto
      have "length (filter (\<lambda>x. x = b) (cols T)) = 1" 
      proof -
        have "length (filter (\<lambda>x. x = b) (cols T)) = 
          card {i. i < dim_col T \<and> col T i = b}"
          unfolding length_filter_conv_card using cols_nth by (metis cols_length) 
        then show ?thesis using less.prems(3) \<open>b \<in> set_cols T\<close>
        by (smt (verit, del_insts) Collect_cong List.finite_set One_nat_def card.empty 
          card.insert distinct_card distinct_filter equals0D list.set(1) set_cols set_filter 
          singleton_conv)
      qed
      then have "length (filter (\<lambda>x. x \<noteq> b) (cols T)) = length (cols T) - 1" 
         using sum_length_filter_compl by (metis add_diff_cancel_left') 
      then show ?thesis unfolding delete_col by auto
    qed
    have "dim_vec b = dim_row T" 
      using b(1) carrier_dim_vec cols_dim set_cols by blast
    have set_cols_T_b: "set_cols ?T_b = set_cols T - {b}"
    proof -
      have "set_cols ?T_b \<subseteq> set_cols T" 
      by (smt (verit) cols_dim cols_mat_of_cols delete_col filter_is_subset order_trans set_cols)
      moreover have "b \<notin> set_cols ?T_b" using \<open>dim_vec b = dim_row T\<close>
        by (subst delet_col_not_in_set_cols, auto)
      ultimately show ?thesis
      by (smt (verit, ccfv_SIG) Diff_insert_absorb Diff_subset_conv Suc_pred' Un_absorb1 b(1) 
      card.insert cols_dim cols_mat_of_cols delete_col dim_col_T_b dim_col_T_gr_0 dim_col_distinct 
      distinct_filter filter_is_subset ft ftb inf_sup_ord(4) insert_Diff insert_union less.prems(3) 
      less_not_refl2 order_trans psubsetI psubset_card_mono)
    qed
    show ?thesis
    proof (cases "set_cols S \<subseteq> span (?T_b)")
      case True
      from cardlt have cardlt': "card (set_cols (?T_b) - set_cols S) < 
        card (set_cols T - set_cols S)"
        using set_cols_T_b by auto
      have "distinct (cols (delete_col T b))" using less.prems(3)
      by (metis cols_dim cols_mat_of_cols delete_col distinct_filter filter_is_subset order_trans)
      then obtain U where U: "dim_col U = dim_col ?T_b" "set_cols S \<subseteq> set_cols U" 
        "set_cols U \<subseteq> set_cols S \<union> set_cols (?T_b)" "distinct (cols U)"
      using less(1)[OF cardlt' S True] by blast
      let ?w = "insert_col U b"
      have dim_col_w: "dim_col ?w = dim_col U + 1" unfolding insert_col by simp
      have "dim_row T = dim_row S" using False 
      by (smt (verit, ccfv_threshold) Lattice_int.span_def True carrier_vecD cols_dim delete_col 
        dim_mult_mat_vec insert_Diff insert_subset mat_of_cols_carrier(2) mem_Collect_eq set_cols 
        subsetI)
      have "dim_vec b = dim_row U" unfolding \<open>dim_vec b = dim_row T\<close> \<open>dim_row T = dim_row S\<close> 
        by (metis U(2) carrier_vecD cols_dim set_cols st(1) subset_iff) 
      then have set_cols_w: "set_cols ?w = set_cols U \<union> {b}" 
        by (subst set_cols_insert_col, auto) 
      have th0: "set_cols S \<subseteq> set_cols ?w"
        using U(2) set_cols_w by auto
      have th1: "set_cols ?w \<subseteq> set_cols S \<union> set_cols T"
        using U b set_cols_w set_cols_T_b by auto
      have bu: "b \<notin> set_cols U"
        using b U 
        by (metis DiffD2 Un_iff insertCI set_cols_T_b sup.orderE)
      from U(1) have "dim_col U = dim_col T - 1"
      using dim_col_T_b by presburger
      then have th2: "dim_col (?w) = dim_col T" unfolding dim_col_w 
      using dim_col_T_gr_0 by linarith
      have th3: "distinct (cols ?w)"
      proof -
        have "b \<notin> set_cols U" using bu by blast 
        then show ?thesis 
        by (metis List.finite_set Suc_pred' U(4) \<open>dim_col U = dim_col T - 1\<close> card_distinct 
          card_insert_disjoint cols_length dim_col_T_gr_0 dim_col_distinct insert_union set_cols 
          set_cols_w th2)
      qed
      from th0 th1 th2 th3  have th: "?P ?w" by blast
      from th show ?thesis by blast
    next
      case False
      then obtain a where a: "a \<in> set_cols S" "a \<notin> span (?T_b)"
        by blast
      have ab: "a \<noteq> b"
        using a b by blast
      have at: "a \<notin> set_cols T"
        using a ab span_base[of a "?T_b"]
        by (metis DiffI empty_iff insert_iff set_cols_T_b)
      let ?insert_a =  "insert_col ?T_b a"
      have set_cols_insert: "set_cols ?insert_a = {a} \<union> set_cols ?T_b" 
      by (smt (verit, ccfv_SIG) Lattice_int.span_def Un_commute a(1) delete_col dim_mult_mat_vec 
        less.prems(2) mat_of_cols_carrier(2) mem_Collect_eq set_cols_insert_col subsetD)
      have dim_col_insert_a: "dim_col (?insert_a) = dim_col T" 
      by (metis One_nat_def Suc_eq_plus1_left Suc_pred' add.commute cols_length dim_col_T_b 
        dim_col_T_gr_0 insert_col list.size(4) mat_of_cols_carrier(3))
      have mlt: "card (set_cols ?insert_a - set_cols S) < card (set_cols T - set_cols S)"
        using cardlt a b
        by (metis insert_Diff1 insert_is_Un set_cols_T_b set_cols_insert)
      have sp': "set_cols S \<subseteq> span (?insert_a)"
      proof
        fix x
        assume xs: "x \<in> set_cols S"
        let ?insert_b =  "mat_of_cols (dim_row T) (b # cols ?insert_a)"
        have T: "set_cols T \<subseteq> set_cols ?insert_b"
          using b 
          by (smt (verit, ccfv_SIG) cols_dim cols_mat_of_cols delete_col dual_order.refl 
            insert_Diff insert_col insert_is_Un insert_subset list.set(2) mat_of_cols_carrier(2) 
            set_cols set_cols_T_b set_cols_insert)
        have bs: "b \<in> span (?insert_a)" 
        by (meson Lattice_int.in_span_delete a(1) a(2) in_mono less.prems(2))
        from xs sp have "x \<in> span T" using less.prems(2) by blast
        with span_mono[OF T] have x: "x \<in> span (?insert_b)" by auto
        from span_trans show "x \<in> span (?insert_a)" 
        by (metis bs delete_col insert_col mat_of_cols_carrier(2) x)
      qed
      from less(1)[OF mlt S sp'] obtain U where U:
        "dim_col U = dim_col (insert_col (?T_b) a)"
        "set_cols S \<subseteq> set_cols U" "set_cols U \<subseteq> set_cols S \<union> set_cols (insert_col (?T_b) a)"
        "distinct (cols U)" 
        by (metis Diff_not_in Lattice_int.span_base a(2) b(1) card_distinct card_insert_disjoint 
          cols_length dim_col_distinct dim_col_insert_a ftb insert_Diff insert_is_Un 
          less.prems(3) set_cols set_cols_T_b set_cols_insert)
      from U a b ft at ct0 have "?P U" 
      using dim_col_insert_a set_cols_T_b set_cols_insert by auto
      then show ?thesis by blast
    qed
  qed
qed



lemma independent_span_bound:
  assumes i: "is_indep S" and d: "distinct (cols T)"
    and sp: "set_cols S \<subseteq> span T"
  shows "dim_col S \<le> dim_col T"
proof -
  obtain t' where t: "dim_col t' = dim_col T"
       "set_cols S \<subseteq> set_cols t'"
       "set_cols t' \<subseteq> set_cols S \<union> set_cols T" 
       "distinct (cols t')"
  using exchange_lemma[OF i sp d] by blast
  then have "dim_col S \<le> dim_col t'" 
    using assms is_indep_distinct[OF i] is_indep_distinct[OF i] by (subst set_cols_mono, auto)
  then show ?thesis using t(1) by auto
qed


lemma gen_lattice_in_span:
assumes "gen_lattice B = gen_lattice B'"
shows "set_cols B \<subseteq> Lattice_int.span B'"
unfolding gen_lattice_def
by (smt (verit, ccfv_SIG) Lattice_int.span_base Lattice_int.span_def assms gen_lattice_def subsetI)

(* A general change of basis theorem is missing, corollary: all bases have the same length *)
lemma basis_exchange:
  assumes gen_eq: "gen_lattice B = gen_lattice B'" and "is_indep B" and "is_indep B'"
  shows "dim_col B = dim_col B'"
proof -
  have "dim_col B \<le> dim_col B'" 
    using assms(2) is_indep_distinct[OF assms(3)] gen_lattice_in_span[OF assms(1)] 
    by (subst independent_span_bound, auto)
  moreover have "dim_col B' \<le> dim_col B" 
    using assms(3) is_indep_distinct[OF assms(2)] gen_lattice_in_span[OF assms(1)[symmetric]] 
    by (subst independent_span_bound, auto)
  ultimately show ?thesis by linarith
qed




























context vec_space
begin
definition lin_indpt_vec :: "'a mat \<Rightarrow>  bool" where
  "lin_indpt_vec A = lin_indpt (set (cols A))"

definition span_vec :: "'a mat \<Rightarrow> 'a vec set" where
  "span_vec A = span (set (cols A))"
end

definition span_vec :: "('a::semiring_1) mat \<Rightarrow> 'a vec set" where
  "span_vec \<equiv> (\<lambda>B. LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row B)) 
  (set (cols B)))"

definition lin_indpt_vec :: "('a::semiring_1) mat \<Rightarrow> bool" where
  "lin_indpt_vec A \<equiv> module.lin_indpt class_ring (module_vec TYPE('a) (dim_row A))
          (set (cols A))"

value "vec_space.lin_indpt_vec n A "


lemma "lin_indpt_vec A = is_indep A"
proof (safe, goal_cases)
  case 1
  then show ?case unfolding lin_indpt_vec_def  sorry
next
  case 2
  then show ?case sorry
qed
  assume assms: "lin_indpt_vec A"
  then have "\<not> module.lin_dep class_ring (module_vec TYPE(int) (dim_row A)) (set (cols A))" 
    unfolding module.lin_dep_def
  show "is_indep A" using assms unfolding lin_indpt_vec_def module.lin_dep_def   sorry
next
  assume "is_indep A"
  show"lin_indpt_vec A" sorry
qed

lemma  gen_lattice_span_int:
  "span_vec ( B) = LinearCombinations.module.span class_ring (module_vec TYPE(int) (dim_row B)) 
    (gen_lattice B)"
sorry

lemma basis_exchange:
  assumes gen_eq: "gen_lattice B = gen_lattice B'" and "is_indep B" and "is_indep B'"
  shows "dim_col B = dim_col B'"
proof -
  define nr where "nr = dim_row B"
  have "dim_row B = dim_row B'" sorry
  have "vec_space.lin_indpt_vec nr (real_of_int_mat B)" sorry
  have "vec_space.lin_indpt_vec nr (real_of_int_mat B')" sorry
  have "vec_space.span_vec nr (real_of_int_mat B) = vec_space.span_vec nr (real_of_int_mat B')"
    using gen_eq unfolding vec_space.span_vec_def sorry
  have "vec_space.rank nr (real_of_int_mat B) = vec_space.rank nr (real_of_int_mat B')" sorry
qed











definition type_ring :: "'a :: ring_1 itself \<Rightarrow> 'a ring" where
  "type_ring _ = \<lparr>carrier = UNIV, mult = (*), one = 1, zero = 0, add = (+)\<rparr>"

lemma type_ring_simps [simp]:
  "carrier (type_ring ty) = UNIV"
  "mult (type_ring ty) = (*)"
  "one (type_ring ty) = 1"
  "zero (type_ring ty) = 0"
  "add (type_ring ty) = (+)"
  by (auto simp: type_ring_def)

lemma Units_type_cring: "Units (type_ring (ty :: 'a :: comm_ring_1 itself)) = {x. x dvd 1}"
  unfolding Units_def by (auto simp: algebra_simps dvd_def)

lemma Units_type_field [simp]: "Units (type_ring (ty :: 'a :: field itself)) = -{0}"
  unfolding Units_type_cring by (auto simp: dvd_field_iff)

interpretation type_ring: ring "type_ring TYPE('a :: ring_1)"
  by standard (auto simp: algebra_simps Units_def add_eq_0_iff)

interpretation type_cring: cring "type_ring TYPE('a :: comm_ring_1)"
  by standard (auto simp: algebra_simps)

interpretation type_field: field "type_ring TYPE('a :: field)"
  by standard auto

interpretation vec_mod: Module.module "type_ring TYPE('a :: comm_ring_1)" "module_vec TYPE('a) n" for n
  by standard
     (use add_inv_exists_vec in \<open>auto simp: module_vec_simps algebra_simps comm_add_vec Units_def\<close>)

interpretation vec: vectorspace "type_ring TYPE('a :: field)" "module_vec TYPE('a) n"
  ..



lemma dim_carrier: "dim_vec z = dim_col A \<Longrightarrow> A *\<^sub>v z \<in> carrier_vec (dim_row A)"
  by (metis carrier_vec_dim_vec dim_mult_mat_vec)


text \<open>Concrete type conversion int vec to real vec\<close>
definition real_of_int_vec :: "int vec \<Rightarrow> real vec"  where
  "real_of_int_vec v = map_vec real_of_int v"

definition real_to_int_vec :: "real vec \<Rightarrow> int vec"  where
  "real_to_int_vec v = map_vec floor v"


lemma[simp]: "dim_vec (real_of_int_vec v) = dim_vec v" 
  unfolding real_of_int_vec_def by auto

lemma real_of_int_vec_nth[simp, intro]: 
  "i<dim_vec v \<Longrightarrow> (real_of_int_vec v) $ i = real_of_int (v$i)"
by (simp add: real_of_int_vec_def)

lemma real_of_int_vec_vec:
  "real_of_int_vec (vec n f) = vec n (real_of_int \<circ> f)"
by (auto simp add: real_of_int_vec_def)

text \<open>Concrete type conversion int mat to real mat\<close>
definition real_of_int_mat :: "int mat \<Rightarrow> real mat"  where
  "real_of_int_mat A = map_mat real_of_int A"

definition real_to_int_mat :: "real mat \<Rightarrow> int mat"  where
  "real_to_int_mat A = map_mat floor A"


lemma[simp]: "dim_col (real_of_int_mat A) = dim_col A" 
  unfolding real_of_int_mat_def by auto

lemma[simp]: "dim_row (real_of_int_mat A) = dim_row A" 
  unfolding real_of_int_mat_def by auto

lemma real_of_int_mat_nth[simp, intro]: 
  "i<dim_row A \<Longrightarrow> j<dim_col A \<Longrightarrow> (real_of_int_mat A) $$ (i,j) = real_of_int (A $$ (i,j))"
by (simp add: real_of_int_mat_def)

lemma real_of_int_mat_mat:
  "real_of_int_mat (mat n m f) = mat n m (real_of_int \<circ> f)"
by (auto simp add: real_of_int_mat_def)


text \<open>Algebraic lattices are discrete additive subgroups of $\mathbb{R}^n$.
  Lattices can be represented by a basis, multiple bases can represent the same lattice.\<close>
type_synonym int_lattice = "int vec set"

(*
definition mat_mult_to_coeffs :: "'b mat \<Rightarrow> 'a vec \<Rightarrow> 'b vec \<Rightarrow> 'a" where
  "mat_mult_to_coeffs A b a = (b $ (THE i. col A i = a))"

lemma dim_vec_lincomb: "dim_vec (vec_mod.lincomb n a b) = n"
unfolding vec_mod.lincomb_def sorry  
  
lemma mat_mult_lincomb:
assumes "dim_vec b = dim_col A"   
shows "A *\<^sub>v b = vec_mod.lincomb (dim_row A) (mat_mult_to_coeffs A b) (set (cols A))"
  (is "?left = ?right")
proof (subst eq_vecI[of ?left ?right], goal_cases)
  case (1 i)
  then show ?case unfolding mat_mult_to_coeffs_def mult_mat_vec_def vec_mod.lincomb_def 
    sorry
next
  case 2
  then show ?case using assms using dim_vec_lincomb by auto
qed auto
*)

text \<open>A lattice basis is a linearly independent set of vectors whose integer span is the lattice.\<close>

(*
definition is_indep :: "int mat \<Rightarrow> bool" where
  "is_indep A \<equiv> vec_mod.lin_indpt (dim_row A) (set (cols A))"

*)

(*L is integer span of B and vectors in B are linearly independent*)
definition is_indep :: "int mat \<Rightarrow> bool" where
  "is_indep A \<equiv> (\<forall>z::real vec. (real_of_int_mat A *\<^sub>v z = 0\<^sub>v (dim_row A) \<and> 
    dim_vec z = dim_col A) \<longrightarrow> z = 0\<^sub>v (dim_vec z))"
 
(*
lemma is_indep_distinct_cols:
  "is_indep A \<Longrightarrow> distinct (cols A)"
proof (rule ccontr)
  assume "is_indep A" "\<not> distinct (cols A)"
  then obtain i j where "i\<noteq>j" "col A i = col A j" "i<dim_col A" "j<dim_col A"
  by (metis cols_length cols_nth distinct_conv_nth)
  define z :: "real vec" where 
    "z = vec (dim_col A) (\<lambda>k. if k = i then 1 else (if k = j then -1 else 0))"
  then have "A *\<^sub>v z = 0\<^sub>v (dim_row A)" 
  proof (subst eq_vecI[of "A *\<^sub>v z" "0\<^sub>v (dim_row A)"], goal_cases)
    case (1 k)
    have "vec (dim_row A) (\<lambda>l. row A l \<bullet> z) $ k = row A k \<bullet> z"
      using "1"(2) by auto
    also have "\<dots> = (\<Sum>ia = 0..<dim_col A.
        row A k $ ia * (if ia = i then 1 else if ia = j then - 1 else 0))"
      unfolding scalar_prod_def z_def by auto 
    also have "\<dots> = row A k $ i - row A k $ j"  sorry
    also have "\<dots> = A $$ (k,i) - A $$ (k,j)" using index_row(1)
      by (metis "1"(2) \<open>i < dim_col A\<close> \<open>j < dim_col A\<close> dim_mult_mat_vec)
    also have "\<dots> = 0" using \<open>col A i = col A j\<close>
      using "1"(2) \<open>i < dim_col A\<close> \<open>j < dim_col A\<close> index_col by fastforce
    finally have "vec (dim_row A) (\<lambda>l. row A l \<bullet> z) $ k = 0" by auto
    then show ?case unfolding mult_mat_vec_def using 1 by auto
  qed auto
  moreover have "dim_vec z = dim_col A" unfolding z_def by auto
  ultimately have z_eq_0:  "z = 0\<^sub>v (dim_vec z)" using \<open>is_indep A\<close> unfolding is_indep_def by auto
  have "z $ i = 0" using z_eq_0 index_zero_vec(1)[OF \<open>i<dim_col A\<close>] 
  unfolding \<open>dim_vec z = dim_col A\<close> by auto
  moreover have "z $ i = 1" unfolding z_def by (simp add: \<open>i < dim_col A\<close>)
  ultimately show False by auto  
qed

  
lemma is_indep :
  "is_indep A = vec_mod.lin_indpt (dim_row A) (set (cols A))"
proof (safe, goal_cases)
  case 1
  have "distinct (cols A)" using is_indep_distinct_cols[OF \<open>is_indep A\<close>] by auto
  obtain Aa a v where props:
    "finite Aa"
    "Aa \<subseteq> set (cols A)"
    "a \<in> Aa \<rightarrow> carrier (type_ring TYPE(real))"
    "vec_mod.lincomb (dim_row A) a Aa = 0\<^sub>v (dim_row A)"
    "v \<in> Aa"
    "a v \<noteq> 0"
    using 1(2) unfolding vec_mod.lin_dep_def 
    by (metis module_vec_simps(2) type_ring_simps(4))
  define z where "z = vec (dim_col A) (\<lambda>i. if col A i \<in> Aa then a (col A i) else 0)"
  have "dim_vec z = dim_col A " unfolding z_def by auto
  moreover have "A *\<^sub>v z = 0\<^sub>v (dim_row A)"
  proof -
    show ?thesis 
    proof (subst eq_vecI[of "A *\<^sub>v z" "0\<^sub>v (dim_row A)"], goal_cases)
      case (1 i)
      then show ?case  unfolding z_def mult_mat_vec_def sorry
    qed auto
  qed




  obtain Aa_list where Aa_list_def: "set Aa_list = Aa" "distinct Aa_list" 
    using finite_list[OF \<open>finite Aa\<close>] props(2) \<open>distinct (cols A)\<close> 
    by (metis set_obtain_sublist)
  define nc where "nc = length Aa_list"
  define a_list where "a_list = (\<lambda>i. a (Aa_list ! i))"
  have rewrite: "vec_mod.lincomb (dim_row A) a Aa = 
    mat_of_cols (dim_row A) (Aa_list) *\<^sub>v (vec nc a_list)"
   sorry
  obtain z where z_def:
    "mat_of_cols (dim_row A) (Aa_list) *\<^sub>v (vec nc a_list) = A *\<^sub>v z" "dim_vec z = (dim_col A)"
  using helper3[of A "dim_row A" "dim_col A" Aa_list "vec nc a_list"]
  by (subst helper3[of A "dim_row A" "dim_col A" Aa_list "vec nc a_list"],
    auto simp add: props Aa_list_def nc_def)
  have *: "A *\<^sub>v z =  0\<^sub>v (dim_row A)" unfolding z_def(1)[symmetric] rewrite[symmetric] 
    using props(4) by auto
  have "z = 0\<^sub>v (dim_col A)" using 1(1) unfolding is_indep_def using  * z_def(2)
    by auto
  then have z_zero: "z $ i = 0" if "i<dim_col A" for i
  using index_zero_vec(1) that by blast
  have "\<exists>i. i<dim_col A \<and> col A i = v" 
  proof -
    have "v\<in>set (cols A)" using props by auto
    then show ?thesis
    by (metis (mono_tags, opaque_lifting) atLeastLessThan_iff cols_def imageE list.set_map set_upt)
  qed
  then obtain i where "i<dim_col A" "col A i = v" 
    by blast
  then have "z$i = a v" using z_def props sorry
  then have "a v = 0" using z_zero[of i] \<open>i<dim_col A\<close> by auto
  then show False using props(6) by auto
next
  case (2)
  then show ?case unfolding is_indep_def 
  proof (safe, goal_cases)
    case (1 z)
    then show ?case sorry
  qed
qed

*)
    

definition is_lattice :: "int_lattice \<Rightarrow> bool" where
  "is_lattice L \<equiv> (\<exists>B::(int mat). 
    L = {B *\<^sub>v z | z::int vec. dim_vec z = dim_col B} 
    \<and> is_indep B)"

    


text \<open>The lattice generated by the column vectors of a matrix. 
  This matrix does not need to be linearly independent. 
  Make certain that the output is indeed a lattice and not the entire space.\<close>
definition gen_lattice :: "int mat \<Rightarrow> int vec set" where
  "gen_lattice A = {A *\<^sub>v z | z::int vec. dim_vec z = dim_col A}"

interpretation lattice_mod: submodule "type_ring TYPE(int)" 
  "gen_lattice A" "module_vec TYPE(int) (dim_row A)" for A
proof (standard, goal_cases)
  case 1
  show ?case by (auto simp add: gen_lattice_def Matrix.module_vec_simps(3) dim_carrier)
next
  case (2 v w)
  obtain zv :: "int vec" where "v = A *\<^sub>v zv" and "dim_vec zv = dim_col A" 
    using 2(1) unfolding gen_lattice_def by blast
  obtain zw :: "int vec" where "w = A *\<^sub>v zw" and "dim_vec zw = dim_col A" 
    using 2(2) unfolding gen_lattice_def by blast
  have "v + w = A *\<^sub>v (zv + zw)" unfolding \<open>v = A *\<^sub>v zv\<close> \<open>w = A *\<^sub>v zw\<close>
    by (metis \<open>dim_vec zv = dim_col A\<close> \<open>dim_vec zw = dim_col A\<close> carrier_mat_triv 
        carrier_vec_dim_vec mult_add_distrib_mat_vec)
  moreover have "dim_vec (zv + zw) = dim_col A"
    by (simp add: \<open>dim_vec zw = dim_col A\<close>)
  ultimately show ?case unfolding gen_lattice_def
    by (metis (mono_tags, lifting) mem_Collect_eq module_vec_simps(1))
next
  case 3
  have "0\<^sub>v (dim_row A) \<in> gen_lattice A"
    by (smt (verit, best) carrier_matI dim_mult_mat_vec gen_lattice_def index_transpose_mat(2) 
        index_transpose_mat(3) mem_Collect_eq minus_cancel_vec mult_mat_vec_carrier 
        mult_minus_distrib_mat_vec zero_carrier_vec)
  then show ?case 
    by (simp add: module_vec_simps(2))
next
  case (4 c v)
  obtain z :: "int vec" where "v = A *\<^sub>v z" and "dim_vec z = dim_col A" 
    using 4(2) unfolding gen_lattice_def by blast
  then have "c \<cdot>\<^sub>v v = A *\<^sub>v (c \<cdot>\<^sub>v z)" and "dim_vec (c \<cdot>\<^sub>v z) = dim_col A" by auto
  then show ?case unfolding gen_lattice_def
    by (metis (mono_tags, lifting) mem_Collect_eq module_vec_simps(4))
qed 

lemma "module (type_ring TYPE(int)) (vec_mod.md (dim_row A) (gen_lattice A))"
  using lattice_mod.submodule_axioms vec_mod.submodule_is_module by blast

text \<open>But we can always find a linearly independent matrix, that spans the same lattice 
  (if the lattice is not the entire space).\<close>


definition basis_of :: "int vec set \<Rightarrow> int mat" where
  "basis_of L = (SOME B. L = gen_lattice B \<and> is_indep B)"

(* A general change of basis theorem is missing, corollary: all bases have the same length *)
lemma basis_exchange:
  assumes "gen_lattice B = gen_lattice B'" and "is_indep B" and "is_indep B'"
  shows "dim_col B = dim_col B'"
proof -
  
qed
  
  


text \<open>The dimension of the lattice is the same for all possible bases -> Show this!\<close>
definition dim_lattice :: "int_lattice \<Rightarrow> nat" where
  "dim_lattice L = (THE x. x = dim_col (basis_of L))"

lemma dim_lattice_gen_lattice:
  assumes "is_indep B"
  shows "dim_lattice (gen_lattice B) = dim_col B"
unfolding dim_lattice_def using assms basis_exchange[of "basis_of (gen_lattice B)" B] 
  by (auto simp add: basis_of_def)(metis (mono_tags, lifting) assms tfl_some)



text \<open>A lattice generated by a linearly independent matrix is indeed a lattice.\<close>
lemma is_lattice_gen_lattice:
  assumes "is_indep A"
  shows "is_lattice (gen_lattice A)"
unfolding is_lattice_def gen_lattice_def using assms by auto


(*linf_norm aus afp/LLL_Basis_Reduction*)



end