theory Lattice_int

imports "Jordan_Normal_Form.Matrix"
        "VectorSpace.VectorSpace"

begin

text \<open>Connect the type vec to records of rings, commutative rings, fields and modules in order to
  use properties of modules such as lin_indpt (linear independence).\<close>
definition type_ring :: "'a :: ring_1 itself \<Rightarrow> 'a ring" where
  "type_ring _ = \<lparr>carrier = UNIV, mult = (*), one = 1, zero = 0, add = (+)\<rparr>"

lemma type_ring_simps [simp]:
  "carrier (type_ring ty) = UNIV"
  "mult (type_ring ty) = (*)"
  "one (type_ring ty) = 1"
  "zero (type_ring ty) = 0"
  "add (type_ring ty) = (+)"
  by (auto simp: type_ring_def)

lemma Units_type_cring: "Units (type_ring (ty :: 'a :: comm_ring_1 itself)) = {x. x dvd 1}"
  unfolding Units_def by (auto simp: algebra_simps dvd_def)

lemma Units_type_field [simp]: "Units (type_ring (ty :: 'a :: field itself)) = -{0}"
  unfolding Units_type_cring by (auto simp: dvd_field_iff)

interpretation type_ring: ring "type_ring TYPE('a :: ring_1)"
  by standard (auto simp: algebra_simps Units_def add_eq_0_iff)

interpretation type_cring: cring "type_ring TYPE('a :: comm_ring_1)"
  by standard (auto simp: algebra_simps)

interpretation type_field: field "type_ring TYPE('a :: field)"
  by standard auto

interpretation vec_mod: Module.module "type_ring TYPE('a :: comm_ring_1)" "module_vec TYPE('a) n" for n
  by standard
     (use add_inv_exists_vec in \<open>auto simp: module_vec_simps algebra_simps comm_add_vec Units_def\<close>)

interpretation vec: vectorspace "type_ring TYPE('a :: field)" "module_vec TYPE('a) n"
  ..

lemma dim_carrier: "dim_vec z = dim_col A \<Longrightarrow> A *\<^sub>v z \<in> carrier_vec (dim_row A)"
  by (metis carrier_vec_dim_vec dim_mult_mat_vec)


text \<open>Concrete type conversion int vec to real vec\<close>
definition real_of_int_vec :: "int vec \<Rightarrow> real vec"  where
  "real_of_int_vec v = map_vec real_of_int v"

definition real_to_int_vec :: "real vec \<Rightarrow> int vec"  where
  "real_to_int_vec v = map_vec floor v"


lemma[simp]: "dim_vec (real_of_int_vec v) = dim_vec v" 
  unfolding real_of_int_vec_def by auto

lemma real_of_int_vec_nth[simp, intro]: 
  "i<dim_vec v \<Longrightarrow> (real_of_int_vec v) $ i = real_of_int (v$i)"
by (simp add: real_of_int_vec_def)

lemma real_of_int_vec_vec:
  "real_of_int_vec (vec n f) = vec n (real_of_int \<circ> f)"
by (auto simp add: real_of_int_vec_def)

text \<open>Concrete type conversion int mat to real mat\<close>
definition real_of_int_mat :: "int mat \<Rightarrow> real mat"  where
  "real_of_int_mat A = map_mat real_of_int A"

definition real_to_int_mat :: "real mat \<Rightarrow> int mat"  where
  "real_to_int_mat A = map_mat floor A"


lemma[simp]: "dim_col (real_of_int_mat A) = dim_col A" 
  unfolding real_of_int_mat_def by auto

lemma[simp]: "dim_row (real_of_int_mat A) = dim_row A" 
  unfolding real_of_int_mat_def by auto

lemma real_of_int_mat_nth[simp, intro]: 
  "i<dim_row A \<Longrightarrow> j<dim_col A \<Longrightarrow> (real_of_int_mat A) $$ (i,j) = real_of_int (A $$ (i,j))"
by (simp add: real_of_int_mat_def)

lemma real_of_int_mat_mat:
  "real_of_int_mat (mat n m f) = mat n m (real_of_int \<circ> f)"
by (auto simp add: real_of_int_mat_def)


text \<open>Algebraic lattices are discrete additive subgroups of $\mathbb{R}^n$.
  Lattices can be represented by a basis, multiple bases can represent the same lattice.\<close>
type_synonym int_lattice = "int vec set"


text \<open>A lattice basis is a linearly independent set of vectors whose integer span is the lattice.\<close>

(*
definition is_indep :: "int mat \<Rightarrow> bool" where
  "is_indep A \<equiv> vec_mod.lin_indpt (dim_row A) (set (cols A))"

*)

(*L is integer span of B and vectors in B are linearly independent*)
definition is_indep :: "int mat \<Rightarrow> bool" where
  "is_indep A \<equiv> (\<forall>z::real vec. (real_of_int_mat A *\<^sub>v z = 0\<^sub>v (dim_row A) \<and> 
    dim_vec z = dim_col A) \<longrightarrow> z = 0\<^sub>v (dim_vec z))"

definition is_lattice :: "int_lattice \<Rightarrow> bool" where
  "is_lattice L \<equiv> (\<exists>B::(int mat). 
    L = {B *\<^sub>v z | z::int vec. dim_vec z = dim_col B} 
    \<and> is_indep B)"


text \<open>The lattice generated by the column vectors of a matrix. 
  This matrix does not need to be linearly independent. 
  Make certain that the output is indeed a lattice and not the entire space.\<close>
definition gen_lattice :: "int mat \<Rightarrow> int vec set" where
  "gen_lattice A = {A *\<^sub>v z | z::int vec. dim_vec z = dim_col A}"

interpretation lattice_mod: submodule "type_ring TYPE(int)" 
  "gen_lattice A" "module_vec TYPE(int) (dim_row A)" for A
proof (standard, goal_cases)
  case 1
  show ?case by (auto simp add: gen_lattice_def Matrix.module_vec_simps(3) dim_carrier)
next
  case (2 v w)
  obtain zv :: "int vec" where "v = A *\<^sub>v zv" and "dim_vec zv = dim_col A" 
    using 2(1) unfolding gen_lattice_def by blast
  obtain zw :: "int vec" where "w = A *\<^sub>v zw" and "dim_vec zw = dim_col A" 
    using 2(2) unfolding gen_lattice_def by blast
  have "v + w = A *\<^sub>v (zv + zw)" unfolding \<open>v = A *\<^sub>v zv\<close> \<open>w = A *\<^sub>v zw\<close>
    by (metis \<open>dim_vec zv = dim_col A\<close> \<open>dim_vec zw = dim_col A\<close> carrier_mat_triv 
        carrier_vec_dim_vec mult_add_distrib_mat_vec)
  moreover have "dim_vec (zv + zw) = dim_col A"
    by (simp add: \<open>dim_vec zw = dim_col A\<close>)
  ultimately show ?case unfolding gen_lattice_def
    by (metis (mono_tags, lifting) mem_Collect_eq module_vec_simps(1))
next
  case 3
  have "0\<^sub>v (dim_row A) \<in> gen_lattice A"
    by (smt (verit, best) carrier_matI dim_mult_mat_vec gen_lattice_def index_transpose_mat(2) 
        index_transpose_mat(3) mem_Collect_eq minus_cancel_vec mult_mat_vec_carrier 
        mult_minus_distrib_mat_vec zero_carrier_vec)
  then show ?case 
    by (simp add: module_vec_simps(2))
next
  case (4 c v)
  obtain z :: "int vec" where "v = A *\<^sub>v z" and "dim_vec z = dim_col A" 
    using 4(2) unfolding gen_lattice_def by blast
  then have "c \<cdot>\<^sub>v v = A *\<^sub>v (c \<cdot>\<^sub>v z)" and "dim_vec (c \<cdot>\<^sub>v z) = dim_col A" by auto
  then show ?case unfolding gen_lattice_def
    by (metis (mono_tags, lifting) mem_Collect_eq module_vec_simps(4))
qed 

lemma "module (type_ring TYPE(int)) (vec_mod.md (dim_row A) (gen_lattice A))"
  using lattice_mod.submodule_axioms vec_mod.submodule_is_module by blast

text \<open>But we can always find a linearly independent matrix, that spans the same lattice 
  (if the lattice is not the entire space).\<close>


definition basis_of :: "int vec set \<Rightarrow> int mat" where
  "basis_of L = (SOME B. L = gen_lattice B \<and> is_indep B)"

(* A general change of basis theorem is missing, corollary: all bases have the same length *)
lemma basis_exchange:
  assumes "gen_lattice B = gen_lattice B'" and "is_indep B" and "is_indep B'"
  shows "dim_col B = dim_col B'"
sorry
  
  


text \<open>The dimension of the lattice is the same for all possible bases -> Show this!\<close>
definition dim_lattice :: "int_lattice \<Rightarrow> nat" where
  "dim_lattice L = (THE x. x = dim_col (basis_of L))"

lemma dim_lattice_gen_lattice:
  assumes "is_indep B"
  shows "dim_lattice (gen_lattice B) = dim_col B"
unfolding dim_lattice_def using assms basis_exchange[of "basis_of (gen_lattice B)" B] 
  by (auto simp add: basis_of_def)(metis (mono_tags, lifting) assms tfl_some)



text \<open>A lattice generated by a linearly independent matrix is indeed a lattice.\<close>
lemma is_lattice_gen_lattice:
  assumes "is_indep A"
  shows "is_lattice (gen_lattice A)"
unfolding is_lattice_def gen_lattice_def using assms by auto


(*linf_norm aus afp/LLL_Basis_Reduction*)



end